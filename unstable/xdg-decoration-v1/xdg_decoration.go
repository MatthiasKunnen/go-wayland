// Generated by go-wayland-scanner
// https://github.com/rajveermalviya/go-wayland/cmd/go-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/d10d18f3d49374d2e3eb96d63511f32795aab5f7/unstable/xdg-decoration/xdg-decoration-unstable-v1.xml
//
// xdg_decoration_unstable_v1 Protocol Copyright:
//
// Copyright Â© 2018 Simon Ser
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice (including the next
// paragraph) shall be included in all copies or substantial portions of the
// Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

package xdg_decoration

import (
	"sync"

	"github.com/rajveermalviya/go-wayland/client"
	xdg_shell "github.com/rajveermalviya/go-wayland/stable/xdg-shell"
)

// DecorationManager : window decoration manager
//
// This interface allows a compositor to announce support for server-side
// decorations.
//
// A window decoration is a set of window controls as deemed appropriate by
// the party managing them, such as user interface components used to move,
// resize and change a window's state.
//
// A client can use this protocol to request being decorated by a supporting
// compositor.
//
// If compositor and client do not negotiate the use of a server-side
// decoration using this protocol, clients continue to self-decorate as they
// see fit.
//
// Warning! The protocol described in this file is experimental and
// backward incompatible changes may be made. Backward compatible changes
// may be added together with the corresponding interface version bump.
// Backward incompatible changes are done by bumping the version number in
// the protocol and interface names and resetting the interface version.
// Once the protocol is to be declared stable, the 'z' prefix and the
// version number in the protocol and interface names are removed and the
// interface version number is reset.
type DecorationManager struct {
	client.BaseProxy
}

// NewDecorationManager : window decoration manager
//
// This interface allows a compositor to announce support for server-side
// decorations.
//
// A window decoration is a set of window controls as deemed appropriate by
// the party managing them, such as user interface components used to move,
// resize and change a window's state.
//
// A client can use this protocol to request being decorated by a supporting
// compositor.
//
// If compositor and client do not negotiate the use of a server-side
// decoration using this protocol, clients continue to self-decorate as they
// see fit.
//
// Warning! The protocol described in this file is experimental and
// backward incompatible changes may be made. Backward compatible changes
// may be added together with the corresponding interface version bump.
// Backward incompatible changes are done by bumping the version number in
// the protocol and interface names and resetting the interface version.
// Once the protocol is to be declared stable, the 'z' prefix and the
// version number in the protocol and interface names are removed and the
// interface version number is reset.
func NewDecorationManager(ctx *client.Context) *DecorationManager {
	zxdgDecorationManagerV1 := &DecorationManager{}
	ctx.Register(zxdgDecorationManagerV1)
	return zxdgDecorationManagerV1
}

// Destroy : destroy the decoration manager object
//
// Destroy the decoration manager. This doesn't destroy objects created
// with the manager.
//
func (i *DecorationManager) Destroy() error {
	defer i.Context().Unregister(i)
	err := i.Context().SendRequest(i, 0)
	return err
}

// GetToplevelDecoration : create a new toplevel decoration object
//
// Create a new decoration object associated with the given toplevel.
//
// Creating an xdg_toplevel_decoration from an xdg_toplevel which has a
// buffer attached or committed is a client error, and any attempts by a
// client to attach or manipulate a buffer prior to the first
// xdg_toplevel_decoration.configure event must also be treated as
// errors.
//
func (i *DecorationManager) GetToplevelDecoration(toplevel *xdg_shell.Toplevel) (*ToplevelDecoration, error) {
	id := NewToplevelDecoration(i.Context())
	err := i.Context().SendRequest(i, 1, id, toplevel)
	return id, err
}

// ToplevelDecoration : decoration object for a toplevel surface
//
// The decoration object allows the compositor to toggle server-side window
// decorations for a toplevel surface. The client can request to switch to
// another mode.
//
// The xdg_toplevel_decoration object must be destroyed before its
// xdg_toplevel.
type ToplevelDecoration struct {
	client.BaseProxy
	mu                sync.RWMutex
	configureHandlers []ToplevelDecorationConfigureHandler
}

// NewToplevelDecoration : decoration object for a toplevel surface
//
// The decoration object allows the compositor to toggle server-side window
// decorations for a toplevel surface. The client can request to switch to
// another mode.
//
// The xdg_toplevel_decoration object must be destroyed before its
// xdg_toplevel.
func NewToplevelDecoration(ctx *client.Context) *ToplevelDecoration {
	zxdgToplevelDecorationV1 := &ToplevelDecoration{}
	ctx.Register(zxdgToplevelDecorationV1)
	return zxdgToplevelDecorationV1
}

// Destroy : destroy the decoration object
//
// Switch back to a mode without any server-side decorations at the next
// commit.
//
func (i *ToplevelDecoration) Destroy() error {
	defer i.Context().Unregister(i)
	err := i.Context().SendRequest(i, 0)
	return err
}

// SetMode : set the decoration mode
//
// Set the toplevel surface decoration mode. This informs the compositor
// that the client prefers the provided decoration mode.
//
// After requesting a decoration mode, the compositor will respond by
// emitting an xdg_surface.configure event. The client should then update
// its content, drawing it without decorations if the received mode is
// server-side decorations. The client must also acknowledge the configure
// when committing the new content (see xdg_surface.ack_configure).
//
// The compositor can decide not to use the client's mode and enforce a
// different mode instead.
//
// Clients whose decoration mode depend on the xdg_toplevel state may send
// a set_mode request in response to an xdg_surface.configure event and wait
// for the next xdg_surface.configure event to prevent unwanted state.
// Such clients are responsible for preventing configure loops and must
// make sure not to send multiple successive set_mode requests with the
// same decoration mode.
//
//  mode: the decoration mode
func (i *ToplevelDecoration) SetMode(mode uint32) error {
	err := i.Context().SendRequest(i, 1, mode)
	return err
}

// UnsetMode : unset the decoration mode
//
// Unset the toplevel surface decoration mode. This informs the compositor
// that the client doesn't prefer a particular decoration mode.
//
// This request has the same semantics as set_mode.
//
func (i *ToplevelDecoration) UnsetMode() error {
	err := i.Context().SendRequest(i, 2)
	return err
}

// ToplevelDecorationError :
const (
	// ToplevelDecorationErrorUnconfiguredBuffer : xdg_toplevel has a buffer attached before configure
	ToplevelDecorationErrorUnconfiguredBuffer = 0
	// ToplevelDecorationErrorAlreadyConstructed : xdg_toplevel already has a decoration object
	ToplevelDecorationErrorAlreadyConstructed = 1
	// ToplevelDecorationErrorOrphaned : xdg_toplevel destroyed before the decoration object
	ToplevelDecorationErrorOrphaned = 2
)

// ToplevelDecorationMode : window decoration modes
//
// These values describe window decoration modes.
const (
	// ToplevelDecorationModeClientSide : no server-side window decoration
	ToplevelDecorationModeClientSide = 1
	// ToplevelDecorationModeServerSide : server-side window decoration
	ToplevelDecorationModeServerSide = 2
)

// ToplevelDecorationConfigureEvent : suggest a surface change
//
// The configure event asks the client to change its decoration mode. The
// configured state should not be applied immediately. Clients must send an
// ack_configure in response to this event. See xdg_surface.configure and
// xdg_surface.ack_configure for details.
//
// A configure event can be sent at any time. The specified mode must be
// obeyed by the client.
type ToplevelDecorationConfigureEvent struct {
	Mode uint32
}

type ToplevelDecorationConfigureHandler interface {
	HandleToplevelDecorationConfigure(ToplevelDecorationConfigureEvent)
}

// AddConfigureHandler : adds handler for ToplevelDecorationConfigureEvent
func (i *ToplevelDecoration) AddConfigureHandler(h ToplevelDecorationConfigureHandler) {
	if h == nil {
		return
	}

	i.mu.Lock()
	i.configureHandlers = append(i.configureHandlers, h)
	i.mu.Unlock()
}

func (i *ToplevelDecoration) RemoveConfigureHandler(h ToplevelDecorationConfigureHandler) {
	i.mu.Lock()
	defer i.mu.Unlock()

	for j, e := range i.configureHandlers {
		if e == h {
			i.configureHandlers = append(i.configureHandlers[:j], i.configureHandlers[j+1:]...)
			break
		}
	}
}

func (i *ToplevelDecoration) Dispatch(event *client.Event) {
	switch event.Opcode {
	case 0:
		i.mu.RLock()
		if len(i.configureHandlers) == 0 {
			i.mu.RUnlock()
			break
		}
		i.mu.RUnlock()

		e := ToplevelDecorationConfigureEvent{
			Mode: event.Uint32(),
		}

		i.mu.RLock()
		for _, h := range i.configureHandlers {
			i.mu.RUnlock()

			h.HandleToplevelDecorationConfigure(e)

			i.mu.RLock()
		}
		i.mu.RUnlock()
	}
}
