// Generated by go-wayland-scanner
// https://github.com/rajveermalviya/go-wayland/cmd/go-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/d10d18f3d49374d2e3eb96d63511f32795aab5f7/stable/presentation-time/presentation-time.xml
//
// PresentationTime Protocol Copyright:
//
// Copyright Â© 2013-2014 Collabora, Ltd.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice (including the next
// paragraph) shall be included in all copies or substantial portions of the
// Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

package presentation_time

import (
	"sync"

	"github.com/rajveermalviya/go-wayland/client"
)

// WpPresentation : timed presentation related wl_surface requests
//
//
//
//
// The main feature of this interface is accurate presentation
// timing feedback to ensure smooth video playback while maintaining
// audio/video synchronization. Some features use the concept of a
// presentation clock, which is defined in the
// presentation.clock_id event.
//
// A content update for a wl_surface is submitted by a
// wl_surface.commit request. Request 'feedback' associates with
// the wl_surface.commit and provides feedback on the content
// update, particularly the final realized presentation time.
//
//
//
// When the final realized presentation time is available, e.g.
// after a framebuffer flip completes, the requested
// presentation_feedback.presented events are sent. The final
// presentation time can differ from the compositor's predicted
// display update time and the update's target time, especially
// when the compositor misses its target vertical blanking period.
type WpPresentation struct {
	client.BaseProxy
	mu              sync.RWMutex
	clockIDHandlers []WpPresentationClockIDHandler
}

// NewWpPresentation : timed presentation related wl_surface requests
//
//
//
//
// The main feature of this interface is accurate presentation
// timing feedback to ensure smooth video playback while maintaining
// audio/video synchronization. Some features use the concept of a
// presentation clock, which is defined in the
// presentation.clock_id event.
//
// A content update for a wl_surface is submitted by a
// wl_surface.commit request. Request 'feedback' associates with
// the wl_surface.commit and provides feedback on the content
// update, particularly the final realized presentation time.
//
//
//
// When the final realized presentation time is available, e.g.
// after a framebuffer flip completes, the requested
// presentation_feedback.presented events are sent. The final
// presentation time can differ from the compositor's predicted
// display update time and the update's target time, especially
// when the compositor misses its target vertical blanking period.
func NewWpPresentation(ctx *client.Context) *WpPresentation {
	wpPresentation := &WpPresentation{}
	ctx.Register(wpPresentation)
	return wpPresentation
}

// Destroy : unbind from the presentation interface
//
// Informs the server that the client will no longer be using
// this protocol object. Existing objects created by this object
// are not affected.
//
func (i *WpPresentation) Destroy() error {
	defer i.Context().Unregister(i)
	err := i.Context().SendRequest(i, 0)
	return err
}

// Feedback : request presentation feedback information
//
// Request presentation feedback for the current content submission
// on the given surface. This creates a new presentation_feedback
// object, which will deliver the feedback information once. If
// multiple presentation_feedback objects are created for the same
// submission, they will all deliver the same information.
//
// For details on what information is returned, see the
// presentation_feedback interface.
//
//  surface: target surface
func (i *WpPresentation) Feedback(surface *client.WlSurface) (*WpPresentationFeedback, error) {
	callback := NewWpPresentationFeedback(i.Context())
	err := i.Context().SendRequest(i, 1, surface, callback)
	return callback, err
}

// WpPresentationError : fatal presentation errors
//
// These fatal protocol errors may be emitted in response to
// illegal presentation requests.
const (
	// WpPresentationErrorInvalidTimestamp : invalid value in tv_nsec
	WpPresentationErrorInvalidTimestamp = 0
	// WpPresentationErrorInvalidFlag : invalid flag
	WpPresentationErrorInvalidFlag = 1
)

// WpPresentationClockIDEvent : clock ID for timestamps
//
// This event tells the client in which clock domain the
// compositor interprets the timestamps used by the presentation
// extension. This clock is called the presentation clock.
//
// The compositor sends this event when the client binds to the
// presentation interface. The presentation clock does not change
// during the lifetime of the client connection.
//
// The clock identifier is platform dependent. On Linux/glibc,
// the identifier value is one of the clockid_t values accepted
// by clock_gettime(). clock_gettime() is defined by
// POSIX.1-2001.
//
// Timestamps in this clock domain are expressed as tv_sec_hi,
// tv_sec_lo, tv_nsec triples, each component being an unsigned
// 32-bit value. Whole seconds are in tv_sec which is a 64-bit
// value combined from tv_sec_hi and tv_sec_lo, and the
// additional fractional part in tv_nsec as nanoseconds. Hence,
// for valid timestamps tv_nsec must be in [0, 999999999].
//
// Note that clock_id applies only to the presentation clock,
// and implies nothing about e.g. the timestamps used in the
// Wayland core protocol input events.
//
// Compositors should prefer a clock which does not jump and is
// not slewed e.g. by NTP. The absolute value of the clock is
// irrelevant. Precision of one millisecond or better is
// recommended. Clients must be able to query the current clock
// value directly, not by asking the compositor.
type WpPresentationClockIDEvent struct {
	ClkID uint32
}

type WpPresentationClockIDHandler interface {
	HandleWpPresentationClockID(WpPresentationClockIDEvent)
}

// AddClockIDHandler : adds handler for WpPresentationClockIDEvent
func (i *WpPresentation) AddClockIDHandler(h WpPresentationClockIDHandler) {
	if h == nil {
		return
	}

	i.mu.Lock()
	i.clockIDHandlers = append(i.clockIDHandlers, h)
	i.mu.Unlock()
}

func (i *WpPresentation) RemoveClockIDHandler(h WpPresentationClockIDHandler) {
	i.mu.Lock()
	defer i.mu.Unlock()

	for j, e := range i.clockIDHandlers {
		if e == h {
			i.clockIDHandlers = append(i.clockIDHandlers[:j], i.clockIDHandlers[j+1:]...)
			break
		}
	}
}

func (i *WpPresentation) Dispatch(event *client.Event) {
	switch event.Opcode {
	case 0:
		i.mu.RLock()
		if len(i.clockIDHandlers) == 0 {
			i.mu.RUnlock()
			break
		}
		i.mu.RUnlock()

		e := WpPresentationClockIDEvent{
			ClkID: event.Uint32(),
		}

		i.mu.RLock()
		for _, h := range i.clockIDHandlers {
			i.mu.RUnlock()

			h.HandleWpPresentationClockID(e)

			i.mu.RLock()
		}
		i.mu.RUnlock()
	}
}

// WpPresentationFeedback : presentation time feedback event
//
// A presentation_feedback object returns an indication that a
// wl_surface content update has become visible to the user.
// One object corresponds to one content update submission
// (wl_surface.commit). There are two possible outcomes: the
// content update is presented to the user, and a presentation
// timestamp delivered; or, the user did not see the content
// update because it was superseded or its surface destroyed,
// and the content update is discarded.
//
// Once a presentation_feedback object has delivered a 'presented'
// or 'discarded' event it is automatically destroyed.
type WpPresentationFeedback struct {
	client.BaseProxy
	mu                 sync.RWMutex
	syncOutputHandlers []WpPresentationFeedbackSyncOutputHandler
	presentedHandlers  []WpPresentationFeedbackPresentedHandler
	discardedHandlers  []WpPresentationFeedbackDiscardedHandler
}

// NewWpPresentationFeedback : presentation time feedback event
//
// A presentation_feedback object returns an indication that a
// wl_surface content update has become visible to the user.
// One object corresponds to one content update submission
// (wl_surface.commit). There are two possible outcomes: the
// content update is presented to the user, and a presentation
// timestamp delivered; or, the user did not see the content
// update because it was superseded or its surface destroyed,
// and the content update is discarded.
//
// Once a presentation_feedback object has delivered a 'presented'
// or 'discarded' event it is automatically destroyed.
func NewWpPresentationFeedback(ctx *client.Context) *WpPresentationFeedback {
	wpPresentationFeedback := &WpPresentationFeedback{}
	ctx.Register(wpPresentationFeedback)
	return wpPresentationFeedback
}

func (i *WpPresentationFeedback) Destroy() error {
	i.Context().Unregister(i)
	return nil
}

// WpPresentationFeedbackKind : bitmask of flags in presented event
//
// These flags provide information about how the presentation of
// the related content update was done. The intent is to help
// clients assess the reliability of the feedback and the visual
// quality with respect to possible tearing and timings. The
// flags are:
//
// VSYNC:
// The presentation was synchronized to the "vertical retrace" by
// the display hardware such that tearing does not happen.
// Relying on user space scheduling is not acceptable for this
// flag. If presentation is done by a copy to the active
// frontbuffer, then it must guarantee that tearing cannot
// happen.
//
// HW_CLOCK:
// The display hardware provided measurements that the hardware
// driver converted into a presentation timestamp. Sampling a
// clock in user space is not acceptable for this flag.
//
// HW_COMPLETION:
// The display hardware signalled that it started using the new
// image content. The opposite of this is e.g. a timer being used
// to guess when the display hardware has switched to the new
// image content.
//
// ZERO_COPY:
// The presentation of this update was done zero-copy. This means
// the buffer from the client was given to display hardware as
// is, without copying it. Compositing with OpenGL counts as
// copying, even if textured directly from the client buffer.
// Possible zero-copy cases include direct scanout of a
// fullscreen surface and a surface on a hardware overlay.
const (
	// WpPresentationFeedbackKindVsync : presentation was vsync'd
	WpPresentationFeedbackKindVsync = 0x1
	// WpPresentationFeedbackKindHwClock : hardware provided the presentation timestamp
	WpPresentationFeedbackKindHwClock = 0x2
	// WpPresentationFeedbackKindHwCompletion : hardware signalled the start of the presentation
	WpPresentationFeedbackKindHwCompletion = 0x4
	// WpPresentationFeedbackKindZeroCopy : presentation was done zero-copy
	WpPresentationFeedbackKindZeroCopy = 0x8
)

// WpPresentationFeedbackSyncOutputEvent : presentation synchronized to this output
//
// As presentation can be synchronized to only one output at a
// time, this event tells which output it was. This event is only
// sent prior to the presented event.
//
// As clients may bind to the same global wl_output multiple
// times, this event is sent for each bound instance that matches
// the synchronized output. If a client has not bound to the
// right wl_output global at all, this event is not sent.
type WpPresentationFeedbackSyncOutputEvent struct {
	Output *client.WlOutput
}

type WpPresentationFeedbackSyncOutputHandler interface {
	HandleWpPresentationFeedbackSyncOutput(WpPresentationFeedbackSyncOutputEvent)
}

// AddSyncOutputHandler : adds handler for WpPresentationFeedbackSyncOutputEvent
func (i *WpPresentationFeedback) AddSyncOutputHandler(h WpPresentationFeedbackSyncOutputHandler) {
	if h == nil {
		return
	}

	i.mu.Lock()
	i.syncOutputHandlers = append(i.syncOutputHandlers, h)
	i.mu.Unlock()
}

func (i *WpPresentationFeedback) RemoveSyncOutputHandler(h WpPresentationFeedbackSyncOutputHandler) {
	i.mu.Lock()
	defer i.mu.Unlock()

	for j, e := range i.syncOutputHandlers {
		if e == h {
			i.syncOutputHandlers = append(i.syncOutputHandlers[:j], i.syncOutputHandlers[j+1:]...)
			break
		}
	}
}

// WpPresentationFeedbackPresentedEvent : the content update was displayed
//
// The associated content update was displayed to the user at the
// indicated time (tv_sec_hi/lo, tv_nsec). For the interpretation of
// the timestamp, see presentation.clock_id event.
//
// The timestamp corresponds to the time when the content update
// turned into light the first time on the surface's main output.
// Compositors may approximate this from the framebuffer flip
// completion events from the system, and the latency of the
// physical display path if known.
//
// This event is preceded by all related sync_output events
// telling which output's refresh cycle the feedback corresponds
// to, i.e. the main output for the surface. Compositors are
// recommended to choose the output containing the largest part
// of the wl_surface, or keeping the output they previously
// chose. Having a stable presentation output association helps
// clients predict future output refreshes (vblank).
//
// The 'refresh' argument gives the compositor's prediction of how
// many nanoseconds after tv_sec, tv_nsec the very next output
// refresh may occur. This is to further aid clients in
// predicting future refreshes, i.e., estimating the timestamps
// targeting the next few vblanks. If such prediction cannot
// usefully be done, the argument is zero.
//
// If the output does not have a constant refresh rate, explicit
// video mode switches excluded, then the refresh argument must
// be zero.
//
// The 64-bit value combined from seq_hi and seq_lo is the value
// of the output's vertical retrace counter when the content
// update was first scanned out to the display. This value must
// be compatible with the definition of MSC in
// GLX_OML_sync_control specification. Note, that if the display
// path has a non-zero latency, the time instant specified by
// this counter may differ from the timestamp's.
//
// If the output does not have a concept of vertical retrace or a
// refresh cycle, or the output device is self-refreshing without
// a way to query the refresh count, then the arguments seq_hi
// and seq_lo must be zero.
type WpPresentationFeedbackPresentedEvent struct {
	TvSecHi uint32
	TvSecLo uint32
	TvNsec  uint32
	Refresh uint32
	SeqHi   uint32
	SeqLo   uint32
	Flags   uint32
}

type WpPresentationFeedbackPresentedHandler interface {
	HandleWpPresentationFeedbackPresented(WpPresentationFeedbackPresentedEvent)
}

// AddPresentedHandler : adds handler for WpPresentationFeedbackPresentedEvent
func (i *WpPresentationFeedback) AddPresentedHandler(h WpPresentationFeedbackPresentedHandler) {
	if h == nil {
		return
	}

	i.mu.Lock()
	i.presentedHandlers = append(i.presentedHandlers, h)
	i.mu.Unlock()
}

func (i *WpPresentationFeedback) RemovePresentedHandler(h WpPresentationFeedbackPresentedHandler) {
	i.mu.Lock()
	defer i.mu.Unlock()

	for j, e := range i.presentedHandlers {
		if e == h {
			i.presentedHandlers = append(i.presentedHandlers[:j], i.presentedHandlers[j+1:]...)
			break
		}
	}
}

// WpPresentationFeedbackDiscardedEvent : the content update was not displayed
//
// The content update was never displayed to the user.
type WpPresentationFeedbackDiscardedEvent struct{}
type WpPresentationFeedbackDiscardedHandler interface {
	HandleWpPresentationFeedbackDiscarded(WpPresentationFeedbackDiscardedEvent)
}

// AddDiscardedHandler : adds handler for WpPresentationFeedbackDiscardedEvent
func (i *WpPresentationFeedback) AddDiscardedHandler(h WpPresentationFeedbackDiscardedHandler) {
	if h == nil {
		return
	}

	i.mu.Lock()
	i.discardedHandlers = append(i.discardedHandlers, h)
	i.mu.Unlock()
}

func (i *WpPresentationFeedback) RemoveDiscardedHandler(h WpPresentationFeedbackDiscardedHandler) {
	i.mu.Lock()
	defer i.mu.Unlock()

	for j, e := range i.discardedHandlers {
		if e == h {
			i.discardedHandlers = append(i.discardedHandlers[:j], i.discardedHandlers[j+1:]...)
			break
		}
	}
}

func (i *WpPresentationFeedback) Dispatch(event *client.Event) {
	switch event.Opcode {
	case 0:
		i.mu.RLock()
		if len(i.syncOutputHandlers) == 0 {
			i.mu.RUnlock()
			break
		}
		i.mu.RUnlock()

		e := WpPresentationFeedbackSyncOutputEvent{
			Output: event.Proxy(i.Context()).(*client.WlOutput),
		}

		i.mu.RLock()
		for _, h := range i.syncOutputHandlers {
			i.mu.RUnlock()

			h.HandleWpPresentationFeedbackSyncOutput(e)

			i.mu.RLock()
		}
		i.mu.RUnlock()
	case 1:
		i.mu.RLock()
		if len(i.presentedHandlers) == 0 {
			i.mu.RUnlock()
			break
		}
		i.mu.RUnlock()

		e := WpPresentationFeedbackPresentedEvent{
			TvSecHi: event.Uint32(),
			TvSecLo: event.Uint32(),
			TvNsec:  event.Uint32(),
			Refresh: event.Uint32(),
			SeqHi:   event.Uint32(),
			SeqLo:   event.Uint32(),
			Flags:   event.Uint32(),
		}

		i.mu.RLock()
		for _, h := range i.presentedHandlers {
			i.mu.RUnlock()

			h.HandleWpPresentationFeedbackPresented(e)

			i.mu.RLock()
		}
		i.mu.RUnlock()
	case 2:
		i.mu.RLock()
		if len(i.discardedHandlers) == 0 {
			i.mu.RUnlock()
			break
		}
		i.mu.RUnlock()

		e := WpPresentationFeedbackDiscardedEvent{}

		i.mu.RLock()
		for _, h := range i.discardedHandlers {
			i.mu.RUnlock()

			h.HandleWpPresentationFeedbackDiscarded(e)

			i.mu.RLock()
		}
		i.mu.RUnlock()
	}
}
