// Generated by go-wayland-scanner
// https://github.com/rajveermalviya/go-wayland/cmd/go-wayland-scanner
// XML file : https://raw.githubusercontent.com/wayland-project/wayland-protocols/f01202f4b73aaf0b9c2c58673d9a932e5a24f054/staging/xdg-activation/xdg-activation-v1.xml
//
// xdg_activation_v1 Protocol Copyright:
//
// Copyright © 2020 Aleix Pol Gonzalez <aleixpol@kde.org>
// Copyright © 2020 Carlos Garnacho <carlosg@gnome.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice (including the next
// paragraph) shall be included in all copies or substantial portions of the
// Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

package xdg_activation

import (
	"sync"

	"github.com/rajveermalviya/go-wayland/wayland/client"
)

// Activation : interface for activating surfaces
//
// A global interface used for informing the compositor about applications
// being activated or started, or for applications to request to be
// activated.
type Activation struct {
	client.BaseProxy
}

// NewActivation : interface for activating surfaces
//
// A global interface used for informing the compositor about applications
// being activated or started, or for applications to request to be
// activated.
func NewActivation(ctx *client.Context) *Activation {
	xdgActivationV1 := &Activation{}
	ctx.Register(xdgActivationV1)
	return xdgActivationV1
}

// Destroy : destroy the xdg_activation object
//
// Notify the compositor that the xdg_activation object will no longer be
// used.
//
// The child objects created via this interface are unaffected and should
// be destroyed separately.
//
func (i *Activation) Destroy() error {
	defer i.Context().Unregister(i)
	err := i.Context().SendRequest(i, 0)
	return err
}

// GetActivationToken : requests a token
//
// Creates an xdg_activation_token_v1 object that will provide
// the initiating client with a unique token for this activation. This
// token should be offered to the clients to be activated.
//
func (i *Activation) GetActivationToken() (*ActivationToken, error) {
	id := NewActivationToken(i.Context())
	err := i.Context().SendRequest(i, 1, id)
	return id, err
}

// Activate : notify new interaction being available
//
// Requests surface activation. It's up to the compositor to display
// this information as desired, for example by placing the surface above
// the rest.
//
// The compositor may know who requested this by checking the activation
// token and might decide not to follow through with the activation if it's
// considered unwanted.
//
// Compositors can ignore unknown activation tokens when an invalid
// token is passed.
//
//  token: the activation token of the initiating client
//  surface: the wl_surface to activate
func (i *Activation) Activate(token string, surface *client.Surface) error {
	err := i.Context().SendRequest(i, 2, token, surface)
	return err
}

// ActivationToken : an exported activation handle
//
// An object for setting up a token and receiving a token handle that can
// be passed as an activation token to another client.
//
// The object is created using the xdg_activation_v1.get_activation_token
// request. This object should then be populated with the app_id, surface
// and serial information and committed. The compositor shall then issue a
// done event with the token. In case the request's parameters are invalid,
// the compositor will provide an invalid token.
type ActivationToken struct {
	client.BaseProxy
	mu           sync.RWMutex
	doneHandlers []ActivationTokenDoneHandler
}

// NewActivationToken : an exported activation handle
//
// An object for setting up a token and receiving a token handle that can
// be passed as an activation token to another client.
//
// The object is created using the xdg_activation_v1.get_activation_token
// request. This object should then be populated with the app_id, surface
// and serial information and committed. The compositor shall then issue a
// done event with the token. In case the request's parameters are invalid,
// the compositor will provide an invalid token.
func NewActivationToken(ctx *client.Context) *ActivationToken {
	xdgActivationTokenV1 := &ActivationToken{}
	ctx.Register(xdgActivationTokenV1)
	return xdgActivationTokenV1
}

// SetSerial : specifies the seat and serial of the activating event
//
// Provides information about the seat and serial event that requested the
// token.
//
// Must be sent before commit. This information is optional.
//
//  serial: the serial of the event that triggered the activation
//  seat: the wl_seat of the event
func (i *ActivationToken) SetSerial(serial uint32, seat *client.Seat) error {
	err := i.Context().SendRequest(i, 0, serial, seat)
	return err
}

// SetAppID : specifies the application being activated
//
// The requesting client can specify an app_id to associate the token
// being created with it.
//
// Must be sent before commit. This information is optional.
//
//  appID: the application id of the client being activated.
func (i *ActivationToken) SetAppID(appID string) error {
	err := i.Context().SendRequest(i, 1, appID)
	return err
}

// SetSurface : specifies the application being activated
//
// The requesting client can specify a surface to associate the token
// being created with it.
//
// Must be triggered before commit. This information is optional.
//
//  surface: the requesting surface
func (i *ActivationToken) SetSurface(surface *client.Surface) error {
	err := i.Context().SendRequest(i, 2, surface)
	return err
}

// Commit : issues the token request
//
// Requests an activation token based on the different parameters that
// have been offered through set_serial, set_surface and set_app_id.
//
func (i *ActivationToken) Commit() error {
	err := i.Context().SendRequest(i, 3)
	return err
}

// Destroy : destroy the xdg_activation_token_v1 object
//
// Notify the compositor that the xdg_activation_token_v1 object will no
// longer be used.
//
func (i *ActivationToken) Destroy() error {
	defer i.Context().Unregister(i)
	err := i.Context().SendRequest(i, 4)
	return err
}

type ActivationTokenError uint32

// ActivationTokenError :
const (
	// ActivationTokenErrorAlreadyUsed : The token has already been used previously
	ActivationTokenErrorAlreadyUsed ActivationTokenError = 0
)

func (e ActivationTokenError) Name() string {
	switch e {
	case ActivationTokenErrorAlreadyUsed:
		return "already_used"
	default:
		return ""
	}
}

func (e ActivationTokenError) Value() string {
	switch e {
	case ActivationTokenErrorAlreadyUsed:
		return "0"
	default:
		return ""
	}
}

func (e ActivationTokenError) String() string {
	return e.Name() + "=" + e.Value()
}

// ActivationTokenDoneEvent : the exported activation token
//
// The 'done' event contains the unique token of this activation request
// and notifies that the provider is done.
//
// Applications will typically receive the token through the
// XDG_ACTIVATION_TOKEN environment variable as set by its launcher, and
// should unset the environment variable right after this request, in
// order to avoid propagating it to child processes.
//
// Applications implementing the D-Bus interface org.freedesktop.Application
// should get their token under XDG_ACTIVATION_TOKEN on their platform_data.
//
// Activation tokens may be transferred across clients through means not
// described in this protocol.
type ActivationTokenDoneEvent struct {
	Token string
}

type ActivationTokenDoneHandler interface {
	HandleActivationTokenDone(ActivationTokenDoneEvent)
}

// AddDoneHandler : adds handler for ActivationTokenDoneEvent
func (i *ActivationToken) AddDoneHandler(h ActivationTokenDoneHandler) {
	if h == nil {
		return
	}

	i.mu.Lock()
	i.doneHandlers = append(i.doneHandlers, h)
	i.mu.Unlock()
}

func (i *ActivationToken) RemoveDoneHandler(h ActivationTokenDoneHandler) {
	i.mu.Lock()
	defer i.mu.Unlock()

	for j, e := range i.doneHandlers {
		if e == h {
			i.doneHandlers = append(i.doneHandlers[:j], i.doneHandlers[j+1:]...)
			break
		}
	}
}

func (i *ActivationToken) Dispatch(event *client.Event) {
	switch event.Opcode {
	case 0:
		i.mu.RLock()
		if len(i.doneHandlers) == 0 {
			i.mu.RUnlock()
			break
		}
		i.mu.RUnlock()

		e := ActivationTokenDoneEvent{
			Token: event.String(),
		}

		i.mu.RLock()
		for _, h := range i.doneHandlers {
			i.mu.RUnlock()

			h.HandleActivationTokenDone(e)

			i.mu.RLock()
		}
		i.mu.RUnlock()
	}
}
