// Generated by go-wayland-scanner
// https://github.com/rajveermalviya/go-wayland/cmd/go-wayland-scanner
// XML file : https://raw.githubusercontent.com/wayland-project/wayland-protocols/1.22/unstable/tablet/tablet-unstable-v2.xml
//
// tablet_unstable_v2 Protocol Copyright:
//
// Copyright 2014 © Stephen "Lyude" Chandler Paul
// Copyright 2015-2016 © Red Hat, Inc.
//
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation files
// (the "Software"), to deal in the Software without restriction,
// including without limitation the rights to use, copy, modify, merge,
// publish, distribute, sublicense, and/or sell copies of the Software,
// and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice (including the
// next paragraph) shall be included in all copies or substantial
// portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
// BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package tablet

import "github.com/rajveermalviya/go-wayland/wayland/client"

// TabletManager : controller object for graphic tablet devices
//
// An object that provides access to the graphics tablets available on this
// system. All tablets are associated with a seat, to get access to the
// actual tablets, use wp_tablet_manager.get_tablet_seat.
type TabletManager struct {
	client.BaseProxy
}

// NewTabletManager : controller object for graphic tablet devices
//
// An object that provides access to the graphics tablets available on this
// system. All tablets are associated with a seat, to get access to the
// actual tablets, use wp_tablet_manager.get_tablet_seat.
func NewTabletManager(ctx *client.Context) *TabletManager {
	zwpTabletManagerV2 := &TabletManager{}
	ctx.Register(zwpTabletManagerV2)
	return zwpTabletManagerV2
}

// GetTabletSeat : get the tablet seat
//
// Get the wp_tablet_seat object for the given seat. This object
// provides access to all graphics tablets in this seat.
//
//  seat: The wl_seat object to retrieve the tablets for
func (i *TabletManager) GetTabletSeat(seat *client.Seat) (*TabletSeat, error) {
	tabletSeat := NewTabletSeat(i.Context())
	const opcode = 0
	const rLen = 8 + 4 + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(r[l:l+4], tabletSeat.ID())
	l += 4
	client.PutUint32(r[l:l+4], seat.ID())
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return tabletSeat, err
}

// Destroy : release the memory for the tablet manager object
//
// Destroy the wp_tablet_manager object. Objects created from this
// object are unaffected and should be destroyed separately.
//
func (i *TabletManager) Destroy() error {
	defer i.Context().Unregister(i)
	const opcode = 1
	const rLen = 8
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// TabletSeat : controller object for graphic tablet devices of a seat
//
// An object that provides access to the graphics tablets available on this
// seat. After binding to this interface, the compositor sends a set of
// wp_tablet_seat.tablet_added and wp_tablet_seat.tool_added events.
type TabletSeat struct {
	client.BaseProxy
	tabletAddedHandlers []TabletSeatTabletAddedHandler
	toolAddedHandlers   []TabletSeatToolAddedHandler
	padAddedHandlers    []TabletSeatPadAddedHandler
}

// NewTabletSeat : controller object for graphic tablet devices of a seat
//
// An object that provides access to the graphics tablets available on this
// seat. After binding to this interface, the compositor sends a set of
// wp_tablet_seat.tablet_added and wp_tablet_seat.tool_added events.
func NewTabletSeat(ctx *client.Context) *TabletSeat {
	zwpTabletSeatV2 := &TabletSeat{}
	ctx.Register(zwpTabletSeatV2)
	return zwpTabletSeatV2
}

// Destroy : release the memory for the tablet seat object
//
// Destroy the wp_tablet_seat object. Objects created from this
// object are unaffected and should be destroyed separately.
//
func (i *TabletSeat) Destroy() error {
	defer i.Context().Unregister(i)
	const opcode = 0
	const rLen = 8
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// TabletSeatTabletAddedEvent : new device notification
//
// This event is sent whenever a new tablet becomes available on this
// seat. This event only provides the object id of the tablet, any
// static information about the tablet (device name, vid/pid, etc.) is
// sent through the wp_tablet interface.
type TabletSeatTabletAddedEvent struct {
	Id *Tablet
}

type TabletSeatTabletAddedHandler interface {
	HandleTabletSeatTabletAdded(TabletSeatTabletAddedEvent)
}

// AddTabletAddedHandler : adds handler for TabletSeatTabletAddedEvent
func (i *TabletSeat) AddTabletAddedHandler(h TabletSeatTabletAddedHandler) {
	if h == nil {
		return
	}

	i.tabletAddedHandlers = append(i.tabletAddedHandlers, h)
}

func (i *TabletSeat) RemoveTabletAddedHandler(h TabletSeatTabletAddedHandler) {
	for j, e := range i.tabletAddedHandlers {
		if e == h {
			i.tabletAddedHandlers = append(i.tabletAddedHandlers[:j], i.tabletAddedHandlers[j+1:]...)
			break
		}
	}
}

// TabletSeatToolAddedEvent : a new tool has been used with a tablet
//
// This event is sent whenever a tool that has not previously been used
// with a tablet comes into use. This event only provides the object id
// of the tool; any static information about the tool (capabilities,
// type, etc.) is sent through the wp_tablet_tool interface.
type TabletSeatToolAddedEvent struct {
	Id *TabletTool
}

type TabletSeatToolAddedHandler interface {
	HandleTabletSeatToolAdded(TabletSeatToolAddedEvent)
}

// AddToolAddedHandler : adds handler for TabletSeatToolAddedEvent
func (i *TabletSeat) AddToolAddedHandler(h TabletSeatToolAddedHandler) {
	if h == nil {
		return
	}

	i.toolAddedHandlers = append(i.toolAddedHandlers, h)
}

func (i *TabletSeat) RemoveToolAddedHandler(h TabletSeatToolAddedHandler) {
	for j, e := range i.toolAddedHandlers {
		if e == h {
			i.toolAddedHandlers = append(i.toolAddedHandlers[:j], i.toolAddedHandlers[j+1:]...)
			break
		}
	}
}

// TabletSeatPadAddedEvent : new pad notification
//
// This event is sent whenever a new pad is known to the system. Typically,
// pads are physically attached to tablets and a pad_added event is
// sent immediately after the wp_tablet_seat.tablet_added.
// However, some standalone pad devices logically attach to tablets at
// runtime, and the client must wait for wp_tablet_pad.enter to know
// the tablet a pad is attached to.
//
// This event only provides the object id of the pad. All further
// features (buttons, strips, rings) are sent through the wp_tablet_pad
// interface.
type TabletSeatPadAddedEvent struct {
	Id *TabletPad
}

type TabletSeatPadAddedHandler interface {
	HandleTabletSeatPadAdded(TabletSeatPadAddedEvent)
}

// AddPadAddedHandler : adds handler for TabletSeatPadAddedEvent
func (i *TabletSeat) AddPadAddedHandler(h TabletSeatPadAddedHandler) {
	if h == nil {
		return
	}

	i.padAddedHandlers = append(i.padAddedHandlers, h)
}

func (i *TabletSeat) RemovePadAddedHandler(h TabletSeatPadAddedHandler) {
	for j, e := range i.padAddedHandlers {
		if e == h {
			i.padAddedHandlers = append(i.padAddedHandlers[:j], i.padAddedHandlers[j+1:]...)
			break
		}
	}
}

func (i *TabletSeat) Dispatch(opcode uint16, fd uintptr, data []byte) {
	switch opcode {
	case 0:
		if len(i.tabletAddedHandlers) == 0 {
			return
		}
		var e TabletSeatTabletAddedEvent
		l := 0
		e.Id = i.Context().GetProxy(client.Uint32(data[l : l+4])).(*Tablet)
		l += 4
		for _, h := range i.tabletAddedHandlers {
			h.HandleTabletSeatTabletAdded(e)
		}
	case 1:
		if len(i.toolAddedHandlers) == 0 {
			return
		}
		var e TabletSeatToolAddedEvent
		l := 0
		e.Id = i.Context().GetProxy(client.Uint32(data[l : l+4])).(*TabletTool)
		l += 4
		for _, h := range i.toolAddedHandlers {
			h.HandleTabletSeatToolAdded(e)
		}
	case 2:
		if len(i.padAddedHandlers) == 0 {
			return
		}
		var e TabletSeatPadAddedEvent
		l := 0
		e.Id = i.Context().GetProxy(client.Uint32(data[l : l+4])).(*TabletPad)
		l += 4
		for _, h := range i.padAddedHandlers {
			h.HandleTabletSeatPadAdded(e)
		}
	}
}

// TabletTool : a physical tablet tool
//
// An object that represents a physical tool that has been, or is
// currently in use with a tablet in this seat. Each wp_tablet_tool
// object stays valid until the client destroys it; the compositor
// reuses the wp_tablet_tool object to indicate that the object's
// respective physical tool has come into proximity of a tablet again.
//
// A wp_tablet_tool object's relation to a physical tool depends on the
// tablet's ability to report serial numbers. If the tablet supports
// this capability, then the object represents a specific physical tool
// and can be identified even when used on multiple tablets.
//
// A tablet tool has a number of static characteristics, e.g. tool type,
// hardware_serial and capabilities. These capabilities are sent in an
// event sequence after the wp_tablet_seat.tool_added event before any
// actual events from this tool. This initial event sequence is
// terminated by a wp_tablet_tool.done event.
//
// Tablet tool events are grouped by wp_tablet_tool.frame events.
// Any events received before a wp_tablet_tool.frame event should be
// considered part of the same hardware state change.
type TabletTool struct {
	client.BaseProxy
	typeHandlers            []TabletToolTypeHandler
	hardwareSerialHandlers  []TabletToolHardwareSerialHandler
	hardwareIdWacomHandlers []TabletToolHardwareIdWacomHandler
	capabilityHandlers      []TabletToolCapabilityHandler
	doneHandlers            []TabletToolDoneHandler
	removedHandlers         []TabletToolRemovedHandler
	proximityInHandlers     []TabletToolProximityInHandler
	proximityOutHandlers    []TabletToolProximityOutHandler
	downHandlers            []TabletToolDownHandler
	upHandlers              []TabletToolUpHandler
	motionHandlers          []TabletToolMotionHandler
	pressureHandlers        []TabletToolPressureHandler
	distanceHandlers        []TabletToolDistanceHandler
	tiltHandlers            []TabletToolTiltHandler
	rotationHandlers        []TabletToolRotationHandler
	sliderHandlers          []TabletToolSliderHandler
	wheelHandlers           []TabletToolWheelHandler
	buttonHandlers          []TabletToolButtonHandler
	frameHandlers           []TabletToolFrameHandler
}

// NewTabletTool : a physical tablet tool
//
// An object that represents a physical tool that has been, or is
// currently in use with a tablet in this seat. Each wp_tablet_tool
// object stays valid until the client destroys it; the compositor
// reuses the wp_tablet_tool object to indicate that the object's
// respective physical tool has come into proximity of a tablet again.
//
// A wp_tablet_tool object's relation to a physical tool depends on the
// tablet's ability to report serial numbers. If the tablet supports
// this capability, then the object represents a specific physical tool
// and can be identified even when used on multiple tablets.
//
// A tablet tool has a number of static characteristics, e.g. tool type,
// hardware_serial and capabilities. These capabilities are sent in an
// event sequence after the wp_tablet_seat.tool_added event before any
// actual events from this tool. This initial event sequence is
// terminated by a wp_tablet_tool.done event.
//
// Tablet tool events are grouped by wp_tablet_tool.frame events.
// Any events received before a wp_tablet_tool.frame event should be
// considered part of the same hardware state change.
func NewTabletTool(ctx *client.Context) *TabletTool {
	zwpTabletToolV2 := &TabletTool{}
	ctx.Register(zwpTabletToolV2)
	return zwpTabletToolV2
}

// SetCursor : set the tablet tool's surface
//
// Sets the surface of the cursor used for this tool on the given
// tablet. This request only takes effect if the tool is in proximity
// of one of the requesting client's surfaces or the surface parameter
// is the current pointer surface. If there was a previous surface set
// with this request it is replaced. If surface is NULL, the cursor
// image is hidden.
//
// The parameters hotspot_x and hotspot_y define the position of the
// pointer surface relative to the pointer location. Its top-left corner
// is always at (x, y) - (hotspot_x, hotspot_y), where (x, y) are the
// coordinates of the pointer location, in surface-local coordinates.
//
// On surface.attach requests to the pointer surface, hotspot_x and
// hotspot_y are decremented by the x and y parameters passed to the
// request. Attach must be confirmed by wl_surface.commit as usual.
//
// The hotspot can also be updated by passing the currently set pointer
// surface to this request with new values for hotspot_x and hotspot_y.
//
// The current and pending input regions of the wl_surface are cleared,
// and wl_surface.set_input_region is ignored until the wl_surface is no
// longer used as the cursor. When the use as a cursor ends, the current
// and pending input regions become undefined, and the wl_surface is
// unmapped.
//
// This request gives the surface the role of a wp_tablet_tool cursor. A
// surface may only ever be used as the cursor surface for one
// wp_tablet_tool. If the surface already has another role or has
// previously been used as cursor surface for a different tool, a
// protocol error is raised.
//
//  serial: serial of the enter event
//  hotspotX: surface-local x coordinate
//  hotspotY: surface-local y coordinate
func (i *TabletTool) SetCursor(serial uint32, surface *client.Surface, hotspotX, hotspotY int32) error {
	const opcode = 0
	const rLen = 8 + 4 + 4 + 4 + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(r[l:l+4], uint32(serial))
	l += 4
	if surface == nil {
		client.PutUint32(r[l:l+4], 0)
		l += 4
	} else {
		client.PutUint32(r[l:l+4], surface.ID())
		l += 4
	}
	client.PutUint32(r[l:l+4], uint32(hotspotX))
	l += 4
	client.PutUint32(r[l:l+4], uint32(hotspotY))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// Destroy : destroy the tool object
//
// This destroys the client's resource for this tool object.
//
func (i *TabletTool) Destroy() error {
	defer i.Context().Unregister(i)
	const opcode = 1
	const rLen = 8
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

type TabletToolType uint32

// TabletToolType : a physical tool type
//
// Describes the physical type of a tool. The physical type of a tool
// generally defines its base usage.
//
// The mouse tool represents a mouse-shaped tool that is not a relative
// device but bound to the tablet's surface, providing absolute
// coordinates.
//
// The lens tool is a mouse-shaped tool with an attached lens to
// provide precision focus.
const (
	// TabletToolTypePen : Pen
	TabletToolTypePen TabletToolType = 0x140
	// TabletToolTypeEraser : Eraser
	TabletToolTypeEraser TabletToolType = 0x141
	// TabletToolTypeBrush : Brush
	TabletToolTypeBrush TabletToolType = 0x142
	// TabletToolTypePencil : Pencil
	TabletToolTypePencil TabletToolType = 0x143
	// TabletToolTypeAirbrush : Airbrush
	TabletToolTypeAirbrush TabletToolType = 0x144
	// TabletToolTypeFinger : Finger
	TabletToolTypeFinger TabletToolType = 0x145
	// TabletToolTypeMouse : Mouse
	TabletToolTypeMouse TabletToolType = 0x146
	// TabletToolTypeLens : Lens
	TabletToolTypeLens TabletToolType = 0x147
)

func (e TabletToolType) Name() string {
	switch e {
	case TabletToolTypePen:
		return "pen"
	case TabletToolTypeEraser:
		return "eraser"
	case TabletToolTypeBrush:
		return "brush"
	case TabletToolTypePencil:
		return "pencil"
	case TabletToolTypeAirbrush:
		return "airbrush"
	case TabletToolTypeFinger:
		return "finger"
	case TabletToolTypeMouse:
		return "mouse"
	case TabletToolTypeLens:
		return "lens"
	default:
		return ""
	}
}

func (e TabletToolType) Value() string {
	switch e {
	case TabletToolTypePen:
		return "0x140"
	case TabletToolTypeEraser:
		return "0x141"
	case TabletToolTypeBrush:
		return "0x142"
	case TabletToolTypePencil:
		return "0x143"
	case TabletToolTypeAirbrush:
		return "0x144"
	case TabletToolTypeFinger:
		return "0x145"
	case TabletToolTypeMouse:
		return "0x146"
	case TabletToolTypeLens:
		return "0x147"
	default:
		return ""
	}
}

func (e TabletToolType) String() string {
	return e.Name() + "=" + e.Value()
}

type TabletToolCapability uint32

// TabletToolCapability : capability flags for a tool
//
// Describes extra capabilities on a tablet.
//
// Any tool must provide x and y values, extra axes are
// device-specific.
const (
	// TabletToolCapabilityTilt : Tilt axes
	TabletToolCapabilityTilt TabletToolCapability = 1
	// TabletToolCapabilityPressure : Pressure axis
	TabletToolCapabilityPressure TabletToolCapability = 2
	// TabletToolCapabilityDistance : Distance axis
	TabletToolCapabilityDistance TabletToolCapability = 3
	// TabletToolCapabilityRotation : Z-rotation axis
	TabletToolCapabilityRotation TabletToolCapability = 4
	// TabletToolCapabilitySlider : Slider axis
	TabletToolCapabilitySlider TabletToolCapability = 5
	// TabletToolCapabilityWheel : Wheel axis
	TabletToolCapabilityWheel TabletToolCapability = 6
)

func (e TabletToolCapability) Name() string {
	switch e {
	case TabletToolCapabilityTilt:
		return "tilt"
	case TabletToolCapabilityPressure:
		return "pressure"
	case TabletToolCapabilityDistance:
		return "distance"
	case TabletToolCapabilityRotation:
		return "rotation"
	case TabletToolCapabilitySlider:
		return "slider"
	case TabletToolCapabilityWheel:
		return "wheel"
	default:
		return ""
	}
}

func (e TabletToolCapability) Value() string {
	switch e {
	case TabletToolCapabilityTilt:
		return "1"
	case TabletToolCapabilityPressure:
		return "2"
	case TabletToolCapabilityDistance:
		return "3"
	case TabletToolCapabilityRotation:
		return "4"
	case TabletToolCapabilitySlider:
		return "5"
	case TabletToolCapabilityWheel:
		return "6"
	default:
		return ""
	}
}

func (e TabletToolCapability) String() string {
	return e.Name() + "=" + e.Value()
}

type TabletToolButtonState uint32

// TabletToolButtonState : physical button state
//
// Describes the physical state of a button that produced the button event.
const (
	// TabletToolButtonStateReleased : button is not pressed
	TabletToolButtonStateReleased TabletToolButtonState = 0
	// TabletToolButtonStatePressed : button is pressed
	TabletToolButtonStatePressed TabletToolButtonState = 1
)

func (e TabletToolButtonState) Name() string {
	switch e {
	case TabletToolButtonStateReleased:
		return "released"
	case TabletToolButtonStatePressed:
		return "pressed"
	default:
		return ""
	}
}

func (e TabletToolButtonState) Value() string {
	switch e {
	case TabletToolButtonStateReleased:
		return "0"
	case TabletToolButtonStatePressed:
		return "1"
	default:
		return ""
	}
}

func (e TabletToolButtonState) String() string {
	return e.Name() + "=" + e.Value()
}

type TabletToolError uint32

// TabletToolError :
const (
	// TabletToolErrorRole : given wl_surface has another role
	TabletToolErrorRole TabletToolError = 0
)

func (e TabletToolError) Name() string {
	switch e {
	case TabletToolErrorRole:
		return "role"
	default:
		return ""
	}
}

func (e TabletToolError) Value() string {
	switch e {
	case TabletToolErrorRole:
		return "0"
	default:
		return ""
	}
}

func (e TabletToolError) String() string {
	return e.Name() + "=" + e.Value()
}

// TabletToolTypeEvent : tool type
//
// The tool type is the high-level type of the tool and usually decides
// the interaction expected from this tool.
//
// This event is sent in the initial burst of events before the
// wp_tablet_tool.done event.
type TabletToolTypeEvent struct {
	ToolType uint32
}

type TabletToolTypeHandler interface {
	HandleTabletToolType(TabletToolTypeEvent)
}

// AddTypeHandler : adds handler for TabletToolTypeEvent
func (i *TabletTool) AddTypeHandler(h TabletToolTypeHandler) {
	if h == nil {
		return
	}

	i.typeHandlers = append(i.typeHandlers, h)
}

func (i *TabletTool) RemoveTypeHandler(h TabletToolTypeHandler) {
	for j, e := range i.typeHandlers {
		if e == h {
			i.typeHandlers = append(i.typeHandlers[:j], i.typeHandlers[j+1:]...)
			break
		}
	}
}

// TabletToolHardwareSerialEvent : unique hardware serial number of the tool
//
// If the physical tool can be identified by a unique 64-bit serial
// number, this event notifies the client of this serial number.
//
// If multiple tablets are available in the same seat and the tool is
// uniquely identifiable by the serial number, that tool may move
// between tablets.
//
// Otherwise, if the tool has no serial number and this event is
// missing, the tool is tied to the tablet it first comes into
// proximity with. Even if the physical tool is used on multiple
// tablets, separate wp_tablet_tool objects will be created, one per
// tablet.
//
// This event is sent in the initial burst of events before the
// wp_tablet_tool.done event.
type TabletToolHardwareSerialEvent struct {
	HardwareSerialHi uint32
	HardwareSerialLo uint32
}

type TabletToolHardwareSerialHandler interface {
	HandleTabletToolHardwareSerial(TabletToolHardwareSerialEvent)
}

// AddHardwareSerialHandler : adds handler for TabletToolHardwareSerialEvent
func (i *TabletTool) AddHardwareSerialHandler(h TabletToolHardwareSerialHandler) {
	if h == nil {
		return
	}

	i.hardwareSerialHandlers = append(i.hardwareSerialHandlers, h)
}

func (i *TabletTool) RemoveHardwareSerialHandler(h TabletToolHardwareSerialHandler) {
	for j, e := range i.hardwareSerialHandlers {
		if e == h {
			i.hardwareSerialHandlers = append(i.hardwareSerialHandlers[:j], i.hardwareSerialHandlers[j+1:]...)
			break
		}
	}
}

// TabletToolHardwareIdWacomEvent : hardware id notification in Wacom's format
//
// This event notifies the client of a hardware id available on this tool.
//
// The hardware id is a device-specific 64-bit id that provides extra
// information about the tool in use, beyond the wl_tool.type
// enumeration. The format of the id is specific to tablets made by
// Wacom Inc. For example, the hardware id of a Wacom Grip
// Pen (a stylus) is 0x802.
//
// This event is sent in the initial burst of events before the
// wp_tablet_tool.done event.
type TabletToolHardwareIdWacomEvent struct {
	HardwareIdHi uint32
	HardwareIdLo uint32
}

type TabletToolHardwareIdWacomHandler interface {
	HandleTabletToolHardwareIdWacom(TabletToolHardwareIdWacomEvent)
}

// AddHardwareIdWacomHandler : adds handler for TabletToolHardwareIdWacomEvent
func (i *TabletTool) AddHardwareIdWacomHandler(h TabletToolHardwareIdWacomHandler) {
	if h == nil {
		return
	}

	i.hardwareIdWacomHandlers = append(i.hardwareIdWacomHandlers, h)
}

func (i *TabletTool) RemoveHardwareIdWacomHandler(h TabletToolHardwareIdWacomHandler) {
	for j, e := range i.hardwareIdWacomHandlers {
		if e == h {
			i.hardwareIdWacomHandlers = append(i.hardwareIdWacomHandlers[:j], i.hardwareIdWacomHandlers[j+1:]...)
			break
		}
	}
}

// TabletToolCapabilityEvent : tool capability notification
//
// This event notifies the client of any capabilities of this tool,
// beyond the main set of x/y axes and tip up/down detection.
//
// One event is sent for each extra capability available on this tool.
//
// This event is sent in the initial burst of events before the
// wp_tablet_tool.done event.
type TabletToolCapabilityEvent struct {
	Capability uint32
}

type TabletToolCapabilityHandler interface {
	HandleTabletToolCapability(TabletToolCapabilityEvent)
}

// AddCapabilityHandler : adds handler for TabletToolCapabilityEvent
func (i *TabletTool) AddCapabilityHandler(h TabletToolCapabilityHandler) {
	if h == nil {
		return
	}

	i.capabilityHandlers = append(i.capabilityHandlers, h)
}

func (i *TabletTool) RemoveCapabilityHandler(h TabletToolCapabilityHandler) {
	for j, e := range i.capabilityHandlers {
		if e == h {
			i.capabilityHandlers = append(i.capabilityHandlers[:j], i.capabilityHandlers[j+1:]...)
			break
		}
	}
}

// TabletToolDoneEvent : tool description events sequence complete
//
// This event signals the end of the initial burst of descriptive
// events. A client may consider the static description of the tool to
// be complete and finalize initialization of the tool.
type TabletToolDoneEvent struct{}
type TabletToolDoneHandler interface {
	HandleTabletToolDone(TabletToolDoneEvent)
}

// AddDoneHandler : adds handler for TabletToolDoneEvent
func (i *TabletTool) AddDoneHandler(h TabletToolDoneHandler) {
	if h == nil {
		return
	}

	i.doneHandlers = append(i.doneHandlers, h)
}

func (i *TabletTool) RemoveDoneHandler(h TabletToolDoneHandler) {
	for j, e := range i.doneHandlers {
		if e == h {
			i.doneHandlers = append(i.doneHandlers[:j], i.doneHandlers[j+1:]...)
			break
		}
	}
}

// TabletToolRemovedEvent : tool removed
//
// This event is sent when the tool is removed from the system and will
// send no further events. Should the physical tool come back into
// proximity later, a new wp_tablet_tool object will be created.
//
// It is compositor-dependent when a tool is removed. A compositor may
// remove a tool on proximity out, tablet removal or any other reason.
// A compositor may also keep a tool alive until shutdown.
//
// If the tool is currently in proximity, a proximity_out event will be
// sent before the removed event. See wp_tablet_tool.proximity_out for
// the handling of any buttons logically down.
//
// When this event is received, the client must wp_tablet_tool.destroy
// the object.
type TabletToolRemovedEvent struct{}
type TabletToolRemovedHandler interface {
	HandleTabletToolRemoved(TabletToolRemovedEvent)
}

// AddRemovedHandler : adds handler for TabletToolRemovedEvent
func (i *TabletTool) AddRemovedHandler(h TabletToolRemovedHandler) {
	if h == nil {
		return
	}

	i.removedHandlers = append(i.removedHandlers, h)
}

func (i *TabletTool) RemoveRemovedHandler(h TabletToolRemovedHandler) {
	for j, e := range i.removedHandlers {
		if e == h {
			i.removedHandlers = append(i.removedHandlers[:j], i.removedHandlers[j+1:]...)
			break
		}
	}
}

// TabletToolProximityInEvent : proximity in event
//
// Notification that this tool is focused on a certain surface.
//
// This event can be received when the tool has moved from one surface to
// another, or when the tool has come back into proximity above the
// surface.
//
// If any button is logically down when the tool comes into proximity,
// the respective button event is sent after the proximity_in event but
// within the same frame as the proximity_in event.
type TabletToolProximityInEvent struct {
	Serial  uint32
	Tablet  *Tablet
	Surface *client.Surface
}

type TabletToolProximityInHandler interface {
	HandleTabletToolProximityIn(TabletToolProximityInEvent)
}

// AddProximityInHandler : adds handler for TabletToolProximityInEvent
func (i *TabletTool) AddProximityInHandler(h TabletToolProximityInHandler) {
	if h == nil {
		return
	}

	i.proximityInHandlers = append(i.proximityInHandlers, h)
}

func (i *TabletTool) RemoveProximityInHandler(h TabletToolProximityInHandler) {
	for j, e := range i.proximityInHandlers {
		if e == h {
			i.proximityInHandlers = append(i.proximityInHandlers[:j], i.proximityInHandlers[j+1:]...)
			break
		}
	}
}

// TabletToolProximityOutEvent : proximity out event
//
// Notification that this tool has either left proximity, or is no
// longer focused on a certain surface.
//
// When the tablet tool leaves proximity of the tablet, button release
// events are sent for each button that was held down at the time of
// leaving proximity. These events are sent before the proximity_out
// event but within the same wp_tablet.frame.
//
// If the tool stays within proximity of the tablet, but the focus
// changes from one surface to another, a button release event may not
// be sent until the button is actually released or the tool leaves the
// proximity of the tablet.
type TabletToolProximityOutEvent struct{}
type TabletToolProximityOutHandler interface {
	HandleTabletToolProximityOut(TabletToolProximityOutEvent)
}

// AddProximityOutHandler : adds handler for TabletToolProximityOutEvent
func (i *TabletTool) AddProximityOutHandler(h TabletToolProximityOutHandler) {
	if h == nil {
		return
	}

	i.proximityOutHandlers = append(i.proximityOutHandlers, h)
}

func (i *TabletTool) RemoveProximityOutHandler(h TabletToolProximityOutHandler) {
	for j, e := range i.proximityOutHandlers {
		if e == h {
			i.proximityOutHandlers = append(i.proximityOutHandlers[:j], i.proximityOutHandlers[j+1:]...)
			break
		}
	}
}

// TabletToolDownEvent : tablet tool is making contact
//
// Sent whenever the tablet tool comes in contact with the surface of the
// tablet.
//
// If the tool is already in contact with the tablet when entering the
// input region, the client owning said region will receive a
// wp_tablet.proximity_in event, followed by a wp_tablet.down
// event and a wp_tablet.frame event.
//
// Note that this event describes logical contact, not physical
// contact. On some devices, a compositor may not consider a tool in
// logical contact until a minimum physical pressure threshold is
// exceeded.
type TabletToolDownEvent struct {
	Serial uint32
}

type TabletToolDownHandler interface {
	HandleTabletToolDown(TabletToolDownEvent)
}

// AddDownHandler : adds handler for TabletToolDownEvent
func (i *TabletTool) AddDownHandler(h TabletToolDownHandler) {
	if h == nil {
		return
	}

	i.downHandlers = append(i.downHandlers, h)
}

func (i *TabletTool) RemoveDownHandler(h TabletToolDownHandler) {
	for j, e := range i.downHandlers {
		if e == h {
			i.downHandlers = append(i.downHandlers[:j], i.downHandlers[j+1:]...)
			break
		}
	}
}

// TabletToolUpEvent : tablet tool is no longer making contact
//
// Sent whenever the tablet tool stops making contact with the surface of
// the tablet, or when the tablet tool moves out of the input region
// and the compositor grab (if any) is dismissed.
//
// If the tablet tool moves out of the input region while in contact
// with the surface of the tablet and the compositor does not have an
// ongoing grab on the surface, the client owning said region will
// receive a wp_tablet.up event, followed by a wp_tablet.proximity_out
// event and a wp_tablet.frame event. If the compositor has an ongoing
// grab on this device, this event sequence is sent whenever the grab
// is dismissed in the future.
//
// Note that this event describes logical contact, not physical
// contact. On some devices, a compositor may not consider a tool out
// of logical contact until physical pressure falls below a specific
// threshold.
type TabletToolUpEvent struct{}
type TabletToolUpHandler interface {
	HandleTabletToolUp(TabletToolUpEvent)
}

// AddUpHandler : adds handler for TabletToolUpEvent
func (i *TabletTool) AddUpHandler(h TabletToolUpHandler) {
	if h == nil {
		return
	}

	i.upHandlers = append(i.upHandlers, h)
}

func (i *TabletTool) RemoveUpHandler(h TabletToolUpHandler) {
	for j, e := range i.upHandlers {
		if e == h {
			i.upHandlers = append(i.upHandlers[:j], i.upHandlers[j+1:]...)
			break
		}
	}
}

// TabletToolMotionEvent : motion event
//
// Sent whenever a tablet tool moves.
type TabletToolMotionEvent struct {
	X float64
	Y float64
}

type TabletToolMotionHandler interface {
	HandleTabletToolMotion(TabletToolMotionEvent)
}

// AddMotionHandler : adds handler for TabletToolMotionEvent
func (i *TabletTool) AddMotionHandler(h TabletToolMotionHandler) {
	if h == nil {
		return
	}

	i.motionHandlers = append(i.motionHandlers, h)
}

func (i *TabletTool) RemoveMotionHandler(h TabletToolMotionHandler) {
	for j, e := range i.motionHandlers {
		if e == h {
			i.motionHandlers = append(i.motionHandlers[:j], i.motionHandlers[j+1:]...)
			break
		}
	}
}

// TabletToolPressureEvent : pressure change event
//
// Sent whenever the pressure axis on a tool changes. The value of this
// event is normalized to a value between 0 and 65535.
//
// Note that pressure may be nonzero even when a tool is not in logical
// contact. See the down and up events for more details.
type TabletToolPressureEvent struct {
	Pressure uint32
}

type TabletToolPressureHandler interface {
	HandleTabletToolPressure(TabletToolPressureEvent)
}

// AddPressureHandler : adds handler for TabletToolPressureEvent
func (i *TabletTool) AddPressureHandler(h TabletToolPressureHandler) {
	if h == nil {
		return
	}

	i.pressureHandlers = append(i.pressureHandlers, h)
}

func (i *TabletTool) RemovePressureHandler(h TabletToolPressureHandler) {
	for j, e := range i.pressureHandlers {
		if e == h {
			i.pressureHandlers = append(i.pressureHandlers[:j], i.pressureHandlers[j+1:]...)
			break
		}
	}
}

// TabletToolDistanceEvent : distance change event
//
// Sent whenever the distance axis on a tool changes. The value of this
// event is normalized to a value between 0 and 65535.
//
// Note that distance may be nonzero even when a tool is not in logical
// contact. See the down and up events for more details.
type TabletToolDistanceEvent struct {
	Distance uint32
}

type TabletToolDistanceHandler interface {
	HandleTabletToolDistance(TabletToolDistanceEvent)
}

// AddDistanceHandler : adds handler for TabletToolDistanceEvent
func (i *TabletTool) AddDistanceHandler(h TabletToolDistanceHandler) {
	if h == nil {
		return
	}

	i.distanceHandlers = append(i.distanceHandlers, h)
}

func (i *TabletTool) RemoveDistanceHandler(h TabletToolDistanceHandler) {
	for j, e := range i.distanceHandlers {
		if e == h {
			i.distanceHandlers = append(i.distanceHandlers[:j], i.distanceHandlers[j+1:]...)
			break
		}
	}
}

// TabletToolTiltEvent : tilt change event
//
// Sent whenever one or both of the tilt axes on a tool change. Each tilt
// value is in degrees, relative to the z-axis of the tablet.
// The angle is positive when the top of a tool tilts along the
// positive x or y axis.
type TabletToolTiltEvent struct {
	TiltX float64
	TiltY float64
}

type TabletToolTiltHandler interface {
	HandleTabletToolTilt(TabletToolTiltEvent)
}

// AddTiltHandler : adds handler for TabletToolTiltEvent
func (i *TabletTool) AddTiltHandler(h TabletToolTiltHandler) {
	if h == nil {
		return
	}

	i.tiltHandlers = append(i.tiltHandlers, h)
}

func (i *TabletTool) RemoveTiltHandler(h TabletToolTiltHandler) {
	for j, e := range i.tiltHandlers {
		if e == h {
			i.tiltHandlers = append(i.tiltHandlers[:j], i.tiltHandlers[j+1:]...)
			break
		}
	}
}

// TabletToolRotationEvent : z-rotation change event
//
// Sent whenever the z-rotation axis on the tool changes. The
// rotation value is in degrees clockwise from the tool's
// logical neutral position.
type TabletToolRotationEvent struct {
	Degrees float64
}

type TabletToolRotationHandler interface {
	HandleTabletToolRotation(TabletToolRotationEvent)
}

// AddRotationHandler : adds handler for TabletToolRotationEvent
func (i *TabletTool) AddRotationHandler(h TabletToolRotationHandler) {
	if h == nil {
		return
	}

	i.rotationHandlers = append(i.rotationHandlers, h)
}

func (i *TabletTool) RemoveRotationHandler(h TabletToolRotationHandler) {
	for j, e := range i.rotationHandlers {
		if e == h {
			i.rotationHandlers = append(i.rotationHandlers[:j], i.rotationHandlers[j+1:]...)
			break
		}
	}
}

// TabletToolSliderEvent : Slider position change event
//
// Sent whenever the slider position on the tool changes. The
// value is normalized between -65535 and 65535, with 0 as the logical
// neutral position of the slider.
//
// The slider is available on e.g. the Wacom Airbrush tool.
type TabletToolSliderEvent struct {
	Position int32
}

type TabletToolSliderHandler interface {
	HandleTabletToolSlider(TabletToolSliderEvent)
}

// AddSliderHandler : adds handler for TabletToolSliderEvent
func (i *TabletTool) AddSliderHandler(h TabletToolSliderHandler) {
	if h == nil {
		return
	}

	i.sliderHandlers = append(i.sliderHandlers, h)
}

func (i *TabletTool) RemoveSliderHandler(h TabletToolSliderHandler) {
	for j, e := range i.sliderHandlers {
		if e == h {
			i.sliderHandlers = append(i.sliderHandlers[:j], i.sliderHandlers[j+1:]...)
			break
		}
	}
}

// TabletToolWheelEvent : Wheel delta event
//
// Sent whenever the wheel on the tool emits an event. This event
// contains two values for the same axis change. The degrees value is
// in the same orientation as the wl_pointer.vertical_scroll axis. The
// clicks value is in discrete logical clicks of the mouse wheel. This
// value may be zero if the movement of the wheel was less
// than one logical click.
//
// Clients should choose either value and avoid mixing degrees and
// clicks. The compositor may accumulate values smaller than a logical
// click and emulate click events when a certain threshold is met.
// Thus, wl_tablet_tool.wheel events with non-zero clicks values may
// have different degrees values.
type TabletToolWheelEvent struct {
	Degrees float64
	Clicks  int32
}

type TabletToolWheelHandler interface {
	HandleTabletToolWheel(TabletToolWheelEvent)
}

// AddWheelHandler : adds handler for TabletToolWheelEvent
func (i *TabletTool) AddWheelHandler(h TabletToolWheelHandler) {
	if h == nil {
		return
	}

	i.wheelHandlers = append(i.wheelHandlers, h)
}

func (i *TabletTool) RemoveWheelHandler(h TabletToolWheelHandler) {
	for j, e := range i.wheelHandlers {
		if e == h {
			i.wheelHandlers = append(i.wheelHandlers[:j], i.wheelHandlers[j+1:]...)
			break
		}
	}
}

// TabletToolButtonEvent : button event
//
// Sent whenever a button on the tool is pressed or released.
//
// If a button is held down when the tool moves in or out of proximity,
// button events are generated by the compositor. See
// wp_tablet_tool.proximity_in and wp_tablet_tool.proximity_out for
// details.
type TabletToolButtonEvent struct {
	Serial uint32
	Button uint32
	State  uint32
}

type TabletToolButtonHandler interface {
	HandleTabletToolButton(TabletToolButtonEvent)
}

// AddButtonHandler : adds handler for TabletToolButtonEvent
func (i *TabletTool) AddButtonHandler(h TabletToolButtonHandler) {
	if h == nil {
		return
	}

	i.buttonHandlers = append(i.buttonHandlers, h)
}

func (i *TabletTool) RemoveButtonHandler(h TabletToolButtonHandler) {
	for j, e := range i.buttonHandlers {
		if e == h {
			i.buttonHandlers = append(i.buttonHandlers[:j], i.buttonHandlers[j+1:]...)
			break
		}
	}
}

// TabletToolFrameEvent : frame event
//
// Marks the end of a series of axis and/or button updates from the
// tablet. The Wayland protocol requires axis updates to be sent
// sequentially, however all events within a frame should be considered
// one hardware event.
type TabletToolFrameEvent struct {
	Time uint32
}

type TabletToolFrameHandler interface {
	HandleTabletToolFrame(TabletToolFrameEvent)
}

// AddFrameHandler : adds handler for TabletToolFrameEvent
func (i *TabletTool) AddFrameHandler(h TabletToolFrameHandler) {
	if h == nil {
		return
	}

	i.frameHandlers = append(i.frameHandlers, h)
}

func (i *TabletTool) RemoveFrameHandler(h TabletToolFrameHandler) {
	for j, e := range i.frameHandlers {
		if e == h {
			i.frameHandlers = append(i.frameHandlers[:j], i.frameHandlers[j+1:]...)
			break
		}
	}
}

func (i *TabletTool) Dispatch(opcode uint16, fd uintptr, data []byte) {
	switch opcode {
	case 0:
		if len(i.typeHandlers) == 0 {
			return
		}
		var e TabletToolTypeEvent
		l := 0
		e.ToolType = client.Uint32(data[l : l+4])
		l += 4
		for _, h := range i.typeHandlers {
			h.HandleTabletToolType(e)
		}
	case 1:
		if len(i.hardwareSerialHandlers) == 0 {
			return
		}
		var e TabletToolHardwareSerialEvent
		l := 0
		e.HardwareSerialHi = client.Uint32(data[l : l+4])
		l += 4
		e.HardwareSerialLo = client.Uint32(data[l : l+4])
		l += 4
		for _, h := range i.hardwareSerialHandlers {
			h.HandleTabletToolHardwareSerial(e)
		}
	case 2:
		if len(i.hardwareIdWacomHandlers) == 0 {
			return
		}
		var e TabletToolHardwareIdWacomEvent
		l := 0
		e.HardwareIdHi = client.Uint32(data[l : l+4])
		l += 4
		e.HardwareIdLo = client.Uint32(data[l : l+4])
		l += 4
		for _, h := range i.hardwareIdWacomHandlers {
			h.HandleTabletToolHardwareIdWacom(e)
		}
	case 3:
		if len(i.capabilityHandlers) == 0 {
			return
		}
		var e TabletToolCapabilityEvent
		l := 0
		e.Capability = client.Uint32(data[l : l+4])
		l += 4
		for _, h := range i.capabilityHandlers {
			h.HandleTabletToolCapability(e)
		}
	case 4:
		if len(i.doneHandlers) == 0 {
			return
		}
		var e TabletToolDoneEvent
		for _, h := range i.doneHandlers {
			h.HandleTabletToolDone(e)
		}
	case 5:
		if len(i.removedHandlers) == 0 {
			return
		}
		var e TabletToolRemovedEvent
		for _, h := range i.removedHandlers {
			h.HandleTabletToolRemoved(e)
		}
	case 6:
		if len(i.proximityInHandlers) == 0 {
			return
		}
		var e TabletToolProximityInEvent
		l := 0
		e.Serial = client.Uint32(data[l : l+4])
		l += 4
		e.Tablet = i.Context().GetProxy(client.Uint32(data[l : l+4])).(*Tablet)
		l += 4
		e.Surface = i.Context().GetProxy(client.Uint32(data[l : l+4])).(*client.Surface)
		l += 4
		for _, h := range i.proximityInHandlers {
			h.HandleTabletToolProximityIn(e)
		}
	case 7:
		if len(i.proximityOutHandlers) == 0 {
			return
		}
		var e TabletToolProximityOutEvent
		for _, h := range i.proximityOutHandlers {
			h.HandleTabletToolProximityOut(e)
		}
	case 8:
		if len(i.downHandlers) == 0 {
			return
		}
		var e TabletToolDownEvent
		l := 0
		e.Serial = client.Uint32(data[l : l+4])
		l += 4
		for _, h := range i.downHandlers {
			h.HandleTabletToolDown(e)
		}
	case 9:
		if len(i.upHandlers) == 0 {
			return
		}
		var e TabletToolUpEvent
		for _, h := range i.upHandlers {
			h.HandleTabletToolUp(e)
		}
	case 10:
		if len(i.motionHandlers) == 0 {
			return
		}
		var e TabletToolMotionEvent
		l := 0
		e.X = client.Fixed(data[l : l+4])
		l += 4
		e.Y = client.Fixed(data[l : l+4])
		l += 4
		for _, h := range i.motionHandlers {
			h.HandleTabletToolMotion(e)
		}
	case 11:
		if len(i.pressureHandlers) == 0 {
			return
		}
		var e TabletToolPressureEvent
		l := 0
		e.Pressure = client.Uint32(data[l : l+4])
		l += 4
		for _, h := range i.pressureHandlers {
			h.HandleTabletToolPressure(e)
		}
	case 12:
		if len(i.distanceHandlers) == 0 {
			return
		}
		var e TabletToolDistanceEvent
		l := 0
		e.Distance = client.Uint32(data[l : l+4])
		l += 4
		for _, h := range i.distanceHandlers {
			h.HandleTabletToolDistance(e)
		}
	case 13:
		if len(i.tiltHandlers) == 0 {
			return
		}
		var e TabletToolTiltEvent
		l := 0
		e.TiltX = client.Fixed(data[l : l+4])
		l += 4
		e.TiltY = client.Fixed(data[l : l+4])
		l += 4
		for _, h := range i.tiltHandlers {
			h.HandleTabletToolTilt(e)
		}
	case 14:
		if len(i.rotationHandlers) == 0 {
			return
		}
		var e TabletToolRotationEvent
		l := 0
		e.Degrees = client.Fixed(data[l : l+4])
		l += 4
		for _, h := range i.rotationHandlers {
			h.HandleTabletToolRotation(e)
		}
	case 15:
		if len(i.sliderHandlers) == 0 {
			return
		}
		var e TabletToolSliderEvent
		l := 0
		e.Position = int32(client.Uint32(data[l : l+4]))
		l += 4
		for _, h := range i.sliderHandlers {
			h.HandleTabletToolSlider(e)
		}
	case 16:
		if len(i.wheelHandlers) == 0 {
			return
		}
		var e TabletToolWheelEvent
		l := 0
		e.Degrees = client.Fixed(data[l : l+4])
		l += 4
		e.Clicks = int32(client.Uint32(data[l : l+4]))
		l += 4
		for _, h := range i.wheelHandlers {
			h.HandleTabletToolWheel(e)
		}
	case 17:
		if len(i.buttonHandlers) == 0 {
			return
		}
		var e TabletToolButtonEvent
		l := 0
		e.Serial = client.Uint32(data[l : l+4])
		l += 4
		e.Button = client.Uint32(data[l : l+4])
		l += 4
		e.State = client.Uint32(data[l : l+4])
		l += 4
		for _, h := range i.buttonHandlers {
			h.HandleTabletToolButton(e)
		}
	case 18:
		if len(i.frameHandlers) == 0 {
			return
		}
		var e TabletToolFrameEvent
		l := 0
		e.Time = client.Uint32(data[l : l+4])
		l += 4
		for _, h := range i.frameHandlers {
			h.HandleTabletToolFrame(e)
		}
	}
}

// Tablet : graphics tablet device
//
// The wp_tablet interface represents one graphics tablet device. The
// tablet interface itself does not generate events; all events are
// generated by wp_tablet_tool objects when in proximity above a tablet.
//
// A tablet has a number of static characteristics, e.g. device name and
// pid/vid. These capabilities are sent in an event sequence after the
// wp_tablet_seat.tablet_added event. This initial event sequence is
// terminated by a wp_tablet.done event.
type Tablet struct {
	client.BaseProxy
	nameHandlers    []TabletNameHandler
	idHandlers      []TabletIdHandler
	pathHandlers    []TabletPathHandler
	doneHandlers    []TabletDoneHandler
	removedHandlers []TabletRemovedHandler
}

// NewTablet : graphics tablet device
//
// The wp_tablet interface represents one graphics tablet device. The
// tablet interface itself does not generate events; all events are
// generated by wp_tablet_tool objects when in proximity above a tablet.
//
// A tablet has a number of static characteristics, e.g. device name and
// pid/vid. These capabilities are sent in an event sequence after the
// wp_tablet_seat.tablet_added event. This initial event sequence is
// terminated by a wp_tablet.done event.
func NewTablet(ctx *client.Context) *Tablet {
	zwpTabletV2 := &Tablet{}
	ctx.Register(zwpTabletV2)
	return zwpTabletV2
}

// Destroy : destroy the tablet object
//
// This destroys the client's resource for this tablet object.
//
func (i *Tablet) Destroy() error {
	defer i.Context().Unregister(i)
	const opcode = 0
	const rLen = 8
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// TabletNameEvent : tablet device name
//
// This event is sent in the initial burst of events before the
// wp_tablet.done event.
type TabletNameEvent struct {
	Name string
}

type TabletNameHandler interface {
	HandleTabletName(TabletNameEvent)
}

// AddNameHandler : adds handler for TabletNameEvent
func (i *Tablet) AddNameHandler(h TabletNameHandler) {
	if h == nil {
		return
	}

	i.nameHandlers = append(i.nameHandlers, h)
}

func (i *Tablet) RemoveNameHandler(h TabletNameHandler) {
	for j, e := range i.nameHandlers {
		if e == h {
			i.nameHandlers = append(i.nameHandlers[:j], i.nameHandlers[j+1:]...)
			break
		}
	}
}

// TabletIdEvent : tablet device USB vendor/product id
//
// This event is sent in the initial burst of events before the
// wp_tablet.done event.
type TabletIdEvent struct {
	Vid uint32
	Pid uint32
}

type TabletIdHandler interface {
	HandleTabletId(TabletIdEvent)
}

// AddIdHandler : adds handler for TabletIdEvent
func (i *Tablet) AddIdHandler(h TabletIdHandler) {
	if h == nil {
		return
	}

	i.idHandlers = append(i.idHandlers, h)
}

func (i *Tablet) RemoveIdHandler(h TabletIdHandler) {
	for j, e := range i.idHandlers {
		if e == h {
			i.idHandlers = append(i.idHandlers[:j], i.idHandlers[j+1:]...)
			break
		}
	}
}

// TabletPathEvent : path to the device
//
// A system-specific device path that indicates which device is behind
// this wp_tablet. This information may be used to gather additional
// information about the device, e.g. through libwacom.
//
// A device may have more than one device path. If so, multiple
// wp_tablet.path events are sent. A device may be emulated and not
// have a device path, and in that case this event will not be sent.
//
// The format of the path is unspecified, it may be a device node, a
// sysfs path, or some other identifier. It is up to the client to
// identify the string provided.
//
// This event is sent in the initial burst of events before the
// wp_tablet.done event.
type TabletPathEvent struct {
	Path string
}

type TabletPathHandler interface {
	HandleTabletPath(TabletPathEvent)
}

// AddPathHandler : adds handler for TabletPathEvent
func (i *Tablet) AddPathHandler(h TabletPathHandler) {
	if h == nil {
		return
	}

	i.pathHandlers = append(i.pathHandlers, h)
}

func (i *Tablet) RemovePathHandler(h TabletPathHandler) {
	for j, e := range i.pathHandlers {
		if e == h {
			i.pathHandlers = append(i.pathHandlers[:j], i.pathHandlers[j+1:]...)
			break
		}
	}
}

// TabletDoneEvent : tablet description events sequence complete
//
// This event is sent immediately to signal the end of the initial
// burst of descriptive events. A client may consider the static
// description of the tablet to be complete and finalize initialization
// of the tablet.
type TabletDoneEvent struct{}
type TabletDoneHandler interface {
	HandleTabletDone(TabletDoneEvent)
}

// AddDoneHandler : adds handler for TabletDoneEvent
func (i *Tablet) AddDoneHandler(h TabletDoneHandler) {
	if h == nil {
		return
	}

	i.doneHandlers = append(i.doneHandlers, h)
}

func (i *Tablet) RemoveDoneHandler(h TabletDoneHandler) {
	for j, e := range i.doneHandlers {
		if e == h {
			i.doneHandlers = append(i.doneHandlers[:j], i.doneHandlers[j+1:]...)
			break
		}
	}
}

// TabletRemovedEvent : tablet removed event
//
// Sent when the tablet has been removed from the system. When a tablet
// is removed, some tools may be removed.
//
// When this event is received, the client must wp_tablet.destroy
// the object.
type TabletRemovedEvent struct{}
type TabletRemovedHandler interface {
	HandleTabletRemoved(TabletRemovedEvent)
}

// AddRemovedHandler : adds handler for TabletRemovedEvent
func (i *Tablet) AddRemovedHandler(h TabletRemovedHandler) {
	if h == nil {
		return
	}

	i.removedHandlers = append(i.removedHandlers, h)
}

func (i *Tablet) RemoveRemovedHandler(h TabletRemovedHandler) {
	for j, e := range i.removedHandlers {
		if e == h {
			i.removedHandlers = append(i.removedHandlers[:j], i.removedHandlers[j+1:]...)
			break
		}
	}
}

func (i *Tablet) Dispatch(opcode uint16, fd uintptr, data []byte) {
	switch opcode {
	case 0:
		if len(i.nameHandlers) == 0 {
			return
		}
		var e TabletNameEvent
		l := 0
		nameLen := client.PaddedLen(int(client.Uint32(data[l : l+4])))
		l += 4
		e.Name = client.String(data[l : l+nameLen])
		l += nameLen
		for _, h := range i.nameHandlers {
			h.HandleTabletName(e)
		}
	case 1:
		if len(i.idHandlers) == 0 {
			return
		}
		var e TabletIdEvent
		l := 0
		e.Vid = client.Uint32(data[l : l+4])
		l += 4
		e.Pid = client.Uint32(data[l : l+4])
		l += 4
		for _, h := range i.idHandlers {
			h.HandleTabletId(e)
		}
	case 2:
		if len(i.pathHandlers) == 0 {
			return
		}
		var e TabletPathEvent
		l := 0
		pathLen := client.PaddedLen(int(client.Uint32(data[l : l+4])))
		l += 4
		e.Path = client.String(data[l : l+pathLen])
		l += pathLen
		for _, h := range i.pathHandlers {
			h.HandleTabletPath(e)
		}
	case 3:
		if len(i.doneHandlers) == 0 {
			return
		}
		var e TabletDoneEvent
		for _, h := range i.doneHandlers {
			h.HandleTabletDone(e)
		}
	case 4:
		if len(i.removedHandlers) == 0 {
			return
		}
		var e TabletRemovedEvent
		for _, h := range i.removedHandlers {
			h.HandleTabletRemoved(e)
		}
	}
}

// TabletPadRing : pad ring
//
// A circular interaction area, such as the touch ring on the Wacom Intuos
// Pro series tablets.
//
// Events on a ring are logically grouped by the wl_tablet_pad_ring.frame
// event.
type TabletPadRing struct {
	client.BaseProxy
	sourceHandlers []TabletPadRingSourceHandler
	angleHandlers  []TabletPadRingAngleHandler
	stopHandlers   []TabletPadRingStopHandler
	frameHandlers  []TabletPadRingFrameHandler
}

// NewTabletPadRing : pad ring
//
// A circular interaction area, such as the touch ring on the Wacom Intuos
// Pro series tablets.
//
// Events on a ring are logically grouped by the wl_tablet_pad_ring.frame
// event.
func NewTabletPadRing(ctx *client.Context) *TabletPadRing {
	zwpTabletPadRingV2 := &TabletPadRing{}
	ctx.Register(zwpTabletPadRingV2)
	return zwpTabletPadRingV2
}

// SetFeedback : set compositor feedback
//
// Request that the compositor use the provided feedback string
// associated with this ring. This request should be issued immediately
// after a wp_tablet_pad_group.mode_switch event from the corresponding
// group is received, or whenever the ring is mapped to a different
// action. See wp_tablet_pad_group.mode_switch for more details.
//
// Clients are encouraged to provide context-aware descriptions for
// the actions associated with the ring; compositors may use this
// information to offer visual feedback about the button layout
// (eg. on-screen displays).
//
// The provided string 'description' is a UTF-8 encoded string to be
// associated with this ring, and is considered user-visible; general
// internationalization rules apply.
//
// The serial argument will be that of the last
// wp_tablet_pad_group.mode_switch event received for the group of this
// ring. Requests providing other serials than the most recent one will be
// ignored.
//
//  description: ring description
//  serial: serial of the mode switch event
func (i *TabletPadRing) SetFeedback(description string, serial uint32) error {
	const opcode = 0
	descriptionLen := client.PaddedLen(len(description) + 1)
	rLen := 8 + (4 + descriptionLen) + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutString(r[l:l+(4+descriptionLen)], description, descriptionLen)
	l += (4 + descriptionLen)
	client.PutUint32(r[l:l+4], uint32(serial))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// Destroy : destroy the ring object
//
// This destroys the client's resource for this ring object.
//
func (i *TabletPadRing) Destroy() error {
	defer i.Context().Unregister(i)
	const opcode = 1
	const rLen = 8
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

type TabletPadRingSource uint32

// TabletPadRingSource : ring axis source
//
// Describes the source types for ring events. This indicates to the
// client how a ring event was physically generated; a client may
// adjust the user interface accordingly. For example, events
// from a "finger" source may trigger kinetic scrolling.
const (
	// TabletPadRingSourceFinger : finger
	TabletPadRingSourceFinger TabletPadRingSource = 1
)

func (e TabletPadRingSource) Name() string {
	switch e {
	case TabletPadRingSourceFinger:
		return "finger"
	default:
		return ""
	}
}

func (e TabletPadRingSource) Value() string {
	switch e {
	case TabletPadRingSourceFinger:
		return "1"
	default:
		return ""
	}
}

func (e TabletPadRingSource) String() string {
	return e.Name() + "=" + e.Value()
}

// TabletPadRingSourceEvent : ring event source
//
// Source information for ring events.
//
// This event does not occur on its own. It is sent before a
// wp_tablet_pad_ring.frame event and carries the source information
// for all events within that frame.
//
// The source specifies how this event was generated. If the source is
// wp_tablet_pad_ring.source.finger, a wp_tablet_pad_ring.stop event
// will be sent when the user lifts the finger off the device.
//
// This event is optional. If the source is unknown for an interaction,
// no event is sent.
type TabletPadRingSourceEvent struct {
	Source uint32
}

type TabletPadRingSourceHandler interface {
	HandleTabletPadRingSource(TabletPadRingSourceEvent)
}

// AddSourceHandler : adds handler for TabletPadRingSourceEvent
func (i *TabletPadRing) AddSourceHandler(h TabletPadRingSourceHandler) {
	if h == nil {
		return
	}

	i.sourceHandlers = append(i.sourceHandlers, h)
}

func (i *TabletPadRing) RemoveSourceHandler(h TabletPadRingSourceHandler) {
	for j, e := range i.sourceHandlers {
		if e == h {
			i.sourceHandlers = append(i.sourceHandlers[:j], i.sourceHandlers[j+1:]...)
			break
		}
	}
}

// TabletPadRingAngleEvent : angle changed
//
// Sent whenever the angle on a ring changes.
//
// The angle is provided in degrees clockwise from the logical
// north of the ring in the pad's current rotation.
type TabletPadRingAngleEvent struct {
	Degrees float64
}

type TabletPadRingAngleHandler interface {
	HandleTabletPadRingAngle(TabletPadRingAngleEvent)
}

// AddAngleHandler : adds handler for TabletPadRingAngleEvent
func (i *TabletPadRing) AddAngleHandler(h TabletPadRingAngleHandler) {
	if h == nil {
		return
	}

	i.angleHandlers = append(i.angleHandlers, h)
}

func (i *TabletPadRing) RemoveAngleHandler(h TabletPadRingAngleHandler) {
	for j, e := range i.angleHandlers {
		if e == h {
			i.angleHandlers = append(i.angleHandlers[:j], i.angleHandlers[j+1:]...)
			break
		}
	}
}

// TabletPadRingStopEvent : interaction stopped
//
// Stop notification for ring events.
//
// For some wp_tablet_pad_ring.source types, a wp_tablet_pad_ring.stop
// event is sent to notify a client that the interaction with the ring
// has terminated. This enables the client to implement kinetic scrolling.
// See the wp_tablet_pad_ring.source documentation for information on
// when this event may be generated.
//
// Any wp_tablet_pad_ring.angle events with the same source after this
// event should be considered as the start of a new interaction.
type TabletPadRingStopEvent struct{}
type TabletPadRingStopHandler interface {
	HandleTabletPadRingStop(TabletPadRingStopEvent)
}

// AddStopHandler : adds handler for TabletPadRingStopEvent
func (i *TabletPadRing) AddStopHandler(h TabletPadRingStopHandler) {
	if h == nil {
		return
	}

	i.stopHandlers = append(i.stopHandlers, h)
}

func (i *TabletPadRing) RemoveStopHandler(h TabletPadRingStopHandler) {
	for j, e := range i.stopHandlers {
		if e == h {
			i.stopHandlers = append(i.stopHandlers[:j], i.stopHandlers[j+1:]...)
			break
		}
	}
}

// TabletPadRingFrameEvent : end of a ring event sequence
//
// Indicates the end of a set of ring events that logically belong
// together. A client is expected to accumulate the data in all events
// within the frame before proceeding.
//
// All wp_tablet_pad_ring events before a wp_tablet_pad_ring.frame event belong
// logically together. For example, on termination of a finger interaction
// on a ring the compositor will send a wp_tablet_pad_ring.source event,
// a wp_tablet_pad_ring.stop event and a wp_tablet_pad_ring.frame event.
//
// A wp_tablet_pad_ring.frame event is sent for every logical event
// group, even if the group only contains a single wp_tablet_pad_ring
// event. Specifically, a client may get a sequence: angle, frame,
// angle, frame, etc.
type TabletPadRingFrameEvent struct {
	Time uint32
}

type TabletPadRingFrameHandler interface {
	HandleTabletPadRingFrame(TabletPadRingFrameEvent)
}

// AddFrameHandler : adds handler for TabletPadRingFrameEvent
func (i *TabletPadRing) AddFrameHandler(h TabletPadRingFrameHandler) {
	if h == nil {
		return
	}

	i.frameHandlers = append(i.frameHandlers, h)
}

func (i *TabletPadRing) RemoveFrameHandler(h TabletPadRingFrameHandler) {
	for j, e := range i.frameHandlers {
		if e == h {
			i.frameHandlers = append(i.frameHandlers[:j], i.frameHandlers[j+1:]...)
			break
		}
	}
}

func (i *TabletPadRing) Dispatch(opcode uint16, fd uintptr, data []byte) {
	switch opcode {
	case 0:
		if len(i.sourceHandlers) == 0 {
			return
		}
		var e TabletPadRingSourceEvent
		l := 0
		e.Source = client.Uint32(data[l : l+4])
		l += 4
		for _, h := range i.sourceHandlers {
			h.HandleTabletPadRingSource(e)
		}
	case 1:
		if len(i.angleHandlers) == 0 {
			return
		}
		var e TabletPadRingAngleEvent
		l := 0
		e.Degrees = client.Fixed(data[l : l+4])
		l += 4
		for _, h := range i.angleHandlers {
			h.HandleTabletPadRingAngle(e)
		}
	case 2:
		if len(i.stopHandlers) == 0 {
			return
		}
		var e TabletPadRingStopEvent
		for _, h := range i.stopHandlers {
			h.HandleTabletPadRingStop(e)
		}
	case 3:
		if len(i.frameHandlers) == 0 {
			return
		}
		var e TabletPadRingFrameEvent
		l := 0
		e.Time = client.Uint32(data[l : l+4])
		l += 4
		for _, h := range i.frameHandlers {
			h.HandleTabletPadRingFrame(e)
		}
	}
}

// TabletPadStrip : pad strip
//
// A linear interaction area, such as the strips found in Wacom Cintiq
// models.
//
// Events on a strip are logically grouped by the wl_tablet_pad_strip.frame
// event.
type TabletPadStrip struct {
	client.BaseProxy
	sourceHandlers   []TabletPadStripSourceHandler
	positionHandlers []TabletPadStripPositionHandler
	stopHandlers     []TabletPadStripStopHandler
	frameHandlers    []TabletPadStripFrameHandler
}

// NewTabletPadStrip : pad strip
//
// A linear interaction area, such as the strips found in Wacom Cintiq
// models.
//
// Events on a strip are logically grouped by the wl_tablet_pad_strip.frame
// event.
func NewTabletPadStrip(ctx *client.Context) *TabletPadStrip {
	zwpTabletPadStripV2 := &TabletPadStrip{}
	ctx.Register(zwpTabletPadStripV2)
	return zwpTabletPadStripV2
}

// SetFeedback : set compositor feedback
//
// Requests the compositor to use the provided feedback string
// associated with this strip. This request should be issued immediately
// after a wp_tablet_pad_group.mode_switch event from the corresponding
// group is received, or whenever the strip is mapped to a different
// action. See wp_tablet_pad_group.mode_switch for more details.
//
// Clients are encouraged to provide context-aware descriptions for
// the actions associated with the strip, and compositors may use this
// information to offer visual feedback about the button layout
// (eg. on-screen displays).
//
// The provided string 'description' is a UTF-8 encoded string to be
// associated with this ring, and is considered user-visible; general
// internationalization rules apply.
//
// The serial argument will be that of the last
// wp_tablet_pad_group.mode_switch event received for the group of this
// strip. Requests providing other serials than the most recent one will be
// ignored.
//
//  description: strip description
//  serial: serial of the mode switch event
func (i *TabletPadStrip) SetFeedback(description string, serial uint32) error {
	const opcode = 0
	descriptionLen := client.PaddedLen(len(description) + 1)
	rLen := 8 + (4 + descriptionLen) + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutString(r[l:l+(4+descriptionLen)], description, descriptionLen)
	l += (4 + descriptionLen)
	client.PutUint32(r[l:l+4], uint32(serial))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// Destroy : destroy the strip object
//
// This destroys the client's resource for this strip object.
//
func (i *TabletPadStrip) Destroy() error {
	defer i.Context().Unregister(i)
	const opcode = 1
	const rLen = 8
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

type TabletPadStripSource uint32

// TabletPadStripSource : strip axis source
//
// Describes the source types for strip events. This indicates to the
// client how a strip event was physically generated; a client may
// adjust the user interface accordingly. For example, events
// from a "finger" source may trigger kinetic scrolling.
const (
	// TabletPadStripSourceFinger : finger
	TabletPadStripSourceFinger TabletPadStripSource = 1
)

func (e TabletPadStripSource) Name() string {
	switch e {
	case TabletPadStripSourceFinger:
		return "finger"
	default:
		return ""
	}
}

func (e TabletPadStripSource) Value() string {
	switch e {
	case TabletPadStripSourceFinger:
		return "1"
	default:
		return ""
	}
}

func (e TabletPadStripSource) String() string {
	return e.Name() + "=" + e.Value()
}

// TabletPadStripSourceEvent : strip event source
//
// Source information for strip events.
//
// This event does not occur on its own. It is sent before a
// wp_tablet_pad_strip.frame event and carries the source information
// for all events within that frame.
//
// The source specifies how this event was generated. If the source is
// wp_tablet_pad_strip.source.finger, a wp_tablet_pad_strip.stop event
// will be sent when the user lifts their finger off the device.
//
// This event is optional. If the source is unknown for an interaction,
// no event is sent.
type TabletPadStripSourceEvent struct {
	Source uint32
}

type TabletPadStripSourceHandler interface {
	HandleTabletPadStripSource(TabletPadStripSourceEvent)
}

// AddSourceHandler : adds handler for TabletPadStripSourceEvent
func (i *TabletPadStrip) AddSourceHandler(h TabletPadStripSourceHandler) {
	if h == nil {
		return
	}

	i.sourceHandlers = append(i.sourceHandlers, h)
}

func (i *TabletPadStrip) RemoveSourceHandler(h TabletPadStripSourceHandler) {
	for j, e := range i.sourceHandlers {
		if e == h {
			i.sourceHandlers = append(i.sourceHandlers[:j], i.sourceHandlers[j+1:]...)
			break
		}
	}
}

// TabletPadStripPositionEvent : position changed
//
// Sent whenever the position on a strip changes.
//
// The position is normalized to a range of [0, 65535], the 0-value
// represents the top-most and/or left-most position of the strip in
// the pad's current rotation.
type TabletPadStripPositionEvent struct {
	Position uint32
}

type TabletPadStripPositionHandler interface {
	HandleTabletPadStripPosition(TabletPadStripPositionEvent)
}

// AddPositionHandler : adds handler for TabletPadStripPositionEvent
func (i *TabletPadStrip) AddPositionHandler(h TabletPadStripPositionHandler) {
	if h == nil {
		return
	}

	i.positionHandlers = append(i.positionHandlers, h)
}

func (i *TabletPadStrip) RemovePositionHandler(h TabletPadStripPositionHandler) {
	for j, e := range i.positionHandlers {
		if e == h {
			i.positionHandlers = append(i.positionHandlers[:j], i.positionHandlers[j+1:]...)
			break
		}
	}
}

// TabletPadStripStopEvent : interaction stopped
//
// Stop notification for strip events.
//
// For some wp_tablet_pad_strip.source types, a wp_tablet_pad_strip.stop
// event is sent to notify a client that the interaction with the strip
// has terminated. This enables the client to implement kinetic
// scrolling. See the wp_tablet_pad_strip.source documentation for
// information on when this event may be generated.
//
// Any wp_tablet_pad_strip.position events with the same source after this
// event should be considered as the start of a new interaction.
type TabletPadStripStopEvent struct{}
type TabletPadStripStopHandler interface {
	HandleTabletPadStripStop(TabletPadStripStopEvent)
}

// AddStopHandler : adds handler for TabletPadStripStopEvent
func (i *TabletPadStrip) AddStopHandler(h TabletPadStripStopHandler) {
	if h == nil {
		return
	}

	i.stopHandlers = append(i.stopHandlers, h)
}

func (i *TabletPadStrip) RemoveStopHandler(h TabletPadStripStopHandler) {
	for j, e := range i.stopHandlers {
		if e == h {
			i.stopHandlers = append(i.stopHandlers[:j], i.stopHandlers[j+1:]...)
			break
		}
	}
}

// TabletPadStripFrameEvent : end of a strip event sequence
//
// Indicates the end of a set of events that represent one logical
// hardware strip event. A client is expected to accumulate the data
// in all events within the frame before proceeding.
//
// All wp_tablet_pad_strip events before a wp_tablet_pad_strip.frame event belong
// logically together. For example, on termination of a finger interaction
// on a strip the compositor will send a wp_tablet_pad_strip.source event,
// a wp_tablet_pad_strip.stop event and a wp_tablet_pad_strip.frame
// event.
//
// A wp_tablet_pad_strip.frame event is sent for every logical event
// group, even if the group only contains a single wp_tablet_pad_strip
// event. Specifically, a client may get a sequence: position, frame,
// position, frame, etc.
type TabletPadStripFrameEvent struct {
	Time uint32
}

type TabletPadStripFrameHandler interface {
	HandleTabletPadStripFrame(TabletPadStripFrameEvent)
}

// AddFrameHandler : adds handler for TabletPadStripFrameEvent
func (i *TabletPadStrip) AddFrameHandler(h TabletPadStripFrameHandler) {
	if h == nil {
		return
	}

	i.frameHandlers = append(i.frameHandlers, h)
}

func (i *TabletPadStrip) RemoveFrameHandler(h TabletPadStripFrameHandler) {
	for j, e := range i.frameHandlers {
		if e == h {
			i.frameHandlers = append(i.frameHandlers[:j], i.frameHandlers[j+1:]...)
			break
		}
	}
}

func (i *TabletPadStrip) Dispatch(opcode uint16, fd uintptr, data []byte) {
	switch opcode {
	case 0:
		if len(i.sourceHandlers) == 0 {
			return
		}
		var e TabletPadStripSourceEvent
		l := 0
		e.Source = client.Uint32(data[l : l+4])
		l += 4
		for _, h := range i.sourceHandlers {
			h.HandleTabletPadStripSource(e)
		}
	case 1:
		if len(i.positionHandlers) == 0 {
			return
		}
		var e TabletPadStripPositionEvent
		l := 0
		e.Position = client.Uint32(data[l : l+4])
		l += 4
		for _, h := range i.positionHandlers {
			h.HandleTabletPadStripPosition(e)
		}
	case 2:
		if len(i.stopHandlers) == 0 {
			return
		}
		var e TabletPadStripStopEvent
		for _, h := range i.stopHandlers {
			h.HandleTabletPadStripStop(e)
		}
	case 3:
		if len(i.frameHandlers) == 0 {
			return
		}
		var e TabletPadStripFrameEvent
		l := 0
		e.Time = client.Uint32(data[l : l+4])
		l += 4
		for _, h := range i.frameHandlers {
			h.HandleTabletPadStripFrame(e)
		}
	}
}

// TabletPadGroup : a set of buttons, rings and strips
//
// A pad group describes a distinct (sub)set of buttons, rings and strips
// present in the tablet. The criteria of this grouping is usually positional,
// eg. if a tablet has buttons on the left and right side, 2 groups will be
// presented. The physical arrangement of groups is undisclosed and may
// change on the fly.
//
// Pad groups will announce their features during pad initialization. Between
// the corresponding wp_tablet_pad.group event and wp_tablet_pad_group.done, the
// pad group will announce the buttons, rings and strips contained in it,
// plus the number of supported modes.
//
// Modes are a mechanism to allow multiple groups of actions for every element
// in the pad group. The number of groups and available modes in each is
// persistent across device plugs. The current mode is user-switchable, it
// will be announced through the wp_tablet_pad_group.mode_switch event both
// whenever it is switched, and after wp_tablet_pad.enter.
//
// The current mode logically applies to all elements in the pad group,
// although it is at clients' discretion whether to actually perform different
// actions, and/or issue the respective .set_feedback requests to notify the
// compositor. See the wp_tablet_pad_group.mode_switch event for more details.
type TabletPadGroup struct {
	client.BaseProxy
	buttonsHandlers    []TabletPadGroupButtonsHandler
	ringHandlers       []TabletPadGroupRingHandler
	stripHandlers      []TabletPadGroupStripHandler
	modesHandlers      []TabletPadGroupModesHandler
	doneHandlers       []TabletPadGroupDoneHandler
	modeSwitchHandlers []TabletPadGroupModeSwitchHandler
}

// NewTabletPadGroup : a set of buttons, rings and strips
//
// A pad group describes a distinct (sub)set of buttons, rings and strips
// present in the tablet. The criteria of this grouping is usually positional,
// eg. if a tablet has buttons on the left and right side, 2 groups will be
// presented. The physical arrangement of groups is undisclosed and may
// change on the fly.
//
// Pad groups will announce their features during pad initialization. Between
// the corresponding wp_tablet_pad.group event and wp_tablet_pad_group.done, the
// pad group will announce the buttons, rings and strips contained in it,
// plus the number of supported modes.
//
// Modes are a mechanism to allow multiple groups of actions for every element
// in the pad group. The number of groups and available modes in each is
// persistent across device plugs. The current mode is user-switchable, it
// will be announced through the wp_tablet_pad_group.mode_switch event both
// whenever it is switched, and after wp_tablet_pad.enter.
//
// The current mode logically applies to all elements in the pad group,
// although it is at clients' discretion whether to actually perform different
// actions, and/or issue the respective .set_feedback requests to notify the
// compositor. See the wp_tablet_pad_group.mode_switch event for more details.
func NewTabletPadGroup(ctx *client.Context) *TabletPadGroup {
	zwpTabletPadGroupV2 := &TabletPadGroup{}
	ctx.Register(zwpTabletPadGroupV2)
	return zwpTabletPadGroupV2
}

// Destroy : destroy the pad object
//
// Destroy the wp_tablet_pad_group object. Objects created from this object
// are unaffected and should be destroyed separately.
//
func (i *TabletPadGroup) Destroy() error {
	defer i.Context().Unregister(i)
	const opcode = 0
	const rLen = 8
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// TabletPadGroupButtonsEvent : buttons announced
//
// Sent on wp_tablet_pad_group initialization to announce the available
// buttons in the group. Button indices start at 0, a button may only be
// in one group at a time.
//
// This event is first sent in the initial burst of events before the
// wp_tablet_pad_group.done event.
//
// Some buttons are reserved by the compositor. These buttons may not be
// assigned to any wp_tablet_pad_group. Compositors may broadcast this
// event in the case of changes to the mapping of these reserved buttons.
// If the compositor happens to reserve all buttons in a group, this event
// will be sent with an empty array.
type TabletPadGroupButtonsEvent struct {
	Buttons []byte
}

type TabletPadGroupButtonsHandler interface {
	HandleTabletPadGroupButtons(TabletPadGroupButtonsEvent)
}

// AddButtonsHandler : adds handler for TabletPadGroupButtonsEvent
func (i *TabletPadGroup) AddButtonsHandler(h TabletPadGroupButtonsHandler) {
	if h == nil {
		return
	}

	i.buttonsHandlers = append(i.buttonsHandlers, h)
}

func (i *TabletPadGroup) RemoveButtonsHandler(h TabletPadGroupButtonsHandler) {
	for j, e := range i.buttonsHandlers {
		if e == h {
			i.buttonsHandlers = append(i.buttonsHandlers[:j], i.buttonsHandlers[j+1:]...)
			break
		}
	}
}

// TabletPadGroupRingEvent : ring announced
//
// Sent on wp_tablet_pad_group initialization to announce available rings.
// One event is sent for each ring available on this pad group.
//
// This event is sent in the initial burst of events before the
// wp_tablet_pad_group.done event.
type TabletPadGroupRingEvent struct {
	Ring *TabletPadRing
}

type TabletPadGroupRingHandler interface {
	HandleTabletPadGroupRing(TabletPadGroupRingEvent)
}

// AddRingHandler : adds handler for TabletPadGroupRingEvent
func (i *TabletPadGroup) AddRingHandler(h TabletPadGroupRingHandler) {
	if h == nil {
		return
	}

	i.ringHandlers = append(i.ringHandlers, h)
}

func (i *TabletPadGroup) RemoveRingHandler(h TabletPadGroupRingHandler) {
	for j, e := range i.ringHandlers {
		if e == h {
			i.ringHandlers = append(i.ringHandlers[:j], i.ringHandlers[j+1:]...)
			break
		}
	}
}

// TabletPadGroupStripEvent : strip announced
//
// Sent on wp_tablet_pad initialization to announce available strips.
// One event is sent for each strip available on this pad group.
//
// This event is sent in the initial burst of events before the
// wp_tablet_pad_group.done event.
type TabletPadGroupStripEvent struct {
	Strip *TabletPadStrip
}

type TabletPadGroupStripHandler interface {
	HandleTabletPadGroupStrip(TabletPadGroupStripEvent)
}

// AddStripHandler : adds handler for TabletPadGroupStripEvent
func (i *TabletPadGroup) AddStripHandler(h TabletPadGroupStripHandler) {
	if h == nil {
		return
	}

	i.stripHandlers = append(i.stripHandlers, h)
}

func (i *TabletPadGroup) RemoveStripHandler(h TabletPadGroupStripHandler) {
	for j, e := range i.stripHandlers {
		if e == h {
			i.stripHandlers = append(i.stripHandlers[:j], i.stripHandlers[j+1:]...)
			break
		}
	}
}

// TabletPadGroupModesEvent : mode-switch ability announced
//
// Sent on wp_tablet_pad_group initialization to announce that the pad
// group may switch between modes. A client may use a mode to store a
// specific configuration for buttons, rings and strips and use the
// wl_tablet_pad_group.mode_switch event to toggle between these
// configurations. Mode indices start at 0.
//
// Switching modes is compositor-dependent. See the
// wp_tablet_pad_group.mode_switch event for more details.
//
// This event is sent in the initial burst of events before the
// wp_tablet_pad_group.done event. This event is only sent when more than
// more than one mode is available.
type TabletPadGroupModesEvent struct {
	Modes uint32
}

type TabletPadGroupModesHandler interface {
	HandleTabletPadGroupModes(TabletPadGroupModesEvent)
}

// AddModesHandler : adds handler for TabletPadGroupModesEvent
func (i *TabletPadGroup) AddModesHandler(h TabletPadGroupModesHandler) {
	if h == nil {
		return
	}

	i.modesHandlers = append(i.modesHandlers, h)
}

func (i *TabletPadGroup) RemoveModesHandler(h TabletPadGroupModesHandler) {
	for j, e := range i.modesHandlers {
		if e == h {
			i.modesHandlers = append(i.modesHandlers[:j], i.modesHandlers[j+1:]...)
			break
		}
	}
}

// TabletPadGroupDoneEvent : tablet group description events sequence complete
//
// This event is sent immediately to signal the end of the initial
// burst of descriptive events. A client may consider the static
// description of the tablet to be complete and finalize initialization
// of the tablet group.
type TabletPadGroupDoneEvent struct{}
type TabletPadGroupDoneHandler interface {
	HandleTabletPadGroupDone(TabletPadGroupDoneEvent)
}

// AddDoneHandler : adds handler for TabletPadGroupDoneEvent
func (i *TabletPadGroup) AddDoneHandler(h TabletPadGroupDoneHandler) {
	if h == nil {
		return
	}

	i.doneHandlers = append(i.doneHandlers, h)
}

func (i *TabletPadGroup) RemoveDoneHandler(h TabletPadGroupDoneHandler) {
	for j, e := range i.doneHandlers {
		if e == h {
			i.doneHandlers = append(i.doneHandlers[:j], i.doneHandlers[j+1:]...)
			break
		}
	}
}

// TabletPadGroupModeSwitchEvent : mode switch event
//
// Notification that the mode was switched.
//
// A mode applies to all buttons, rings and strips in a group
// simultaneously, but a client is not required to assign different actions
// for each mode. For example, a client may have mode-specific button
// mappings but map the ring to vertical scrolling in all modes. Mode
// indices start at 0.
//
// Switching modes is compositor-dependent. The compositor may provide
// visual cues to the client about the mode, e.g. by toggling LEDs on
// the tablet device. Mode-switching may be software-controlled or
// controlled by one or more physical buttons. For example, on a Wacom
// Intuos Pro, the button inside the ring may be assigned to switch
// between modes.
//
// The compositor will also send this event after wp_tablet_pad.enter on
// each group in order to notify of the current mode. Groups that only
// feature one mode will use mode=0 when emitting this event.
//
// If a button action in the new mode differs from the action in the
// previous mode, the client should immediately issue a
// wp_tablet_pad.set_feedback request for each changed button.
//
// If a ring or strip action in the new mode differs from the action
// in the previous mode, the client should immediately issue a
// wp_tablet_ring.set_feedback or wp_tablet_strip.set_feedback request
// for each changed ring or strip.
type TabletPadGroupModeSwitchEvent struct {
	Time   uint32
	Serial uint32
	Mode   uint32
}

type TabletPadGroupModeSwitchHandler interface {
	HandleTabletPadGroupModeSwitch(TabletPadGroupModeSwitchEvent)
}

// AddModeSwitchHandler : adds handler for TabletPadGroupModeSwitchEvent
func (i *TabletPadGroup) AddModeSwitchHandler(h TabletPadGroupModeSwitchHandler) {
	if h == nil {
		return
	}

	i.modeSwitchHandlers = append(i.modeSwitchHandlers, h)
}

func (i *TabletPadGroup) RemoveModeSwitchHandler(h TabletPadGroupModeSwitchHandler) {
	for j, e := range i.modeSwitchHandlers {
		if e == h {
			i.modeSwitchHandlers = append(i.modeSwitchHandlers[:j], i.modeSwitchHandlers[j+1:]...)
			break
		}
	}
}

func (i *TabletPadGroup) Dispatch(opcode uint16, fd uintptr, data []byte) {
	switch opcode {
	case 0:
		if len(i.buttonsHandlers) == 0 {
			return
		}
		var e TabletPadGroupButtonsEvent
		l := 0
		buttonsLen := int(client.Uint32(data[l : l+4]))
		l += 4
		e.Buttons = make([]byte, buttonsLen)
		copy(e.Buttons, data[l:l+buttonsLen])
		l += buttonsLen
		for _, h := range i.buttonsHandlers {
			h.HandleTabletPadGroupButtons(e)
		}
	case 1:
		if len(i.ringHandlers) == 0 {
			return
		}
		var e TabletPadGroupRingEvent
		l := 0
		e.Ring = i.Context().GetProxy(client.Uint32(data[l : l+4])).(*TabletPadRing)
		l += 4
		for _, h := range i.ringHandlers {
			h.HandleTabletPadGroupRing(e)
		}
	case 2:
		if len(i.stripHandlers) == 0 {
			return
		}
		var e TabletPadGroupStripEvent
		l := 0
		e.Strip = i.Context().GetProxy(client.Uint32(data[l : l+4])).(*TabletPadStrip)
		l += 4
		for _, h := range i.stripHandlers {
			h.HandleTabletPadGroupStrip(e)
		}
	case 3:
		if len(i.modesHandlers) == 0 {
			return
		}
		var e TabletPadGroupModesEvent
		l := 0
		e.Modes = client.Uint32(data[l : l+4])
		l += 4
		for _, h := range i.modesHandlers {
			h.HandleTabletPadGroupModes(e)
		}
	case 4:
		if len(i.doneHandlers) == 0 {
			return
		}
		var e TabletPadGroupDoneEvent
		for _, h := range i.doneHandlers {
			h.HandleTabletPadGroupDone(e)
		}
	case 5:
		if len(i.modeSwitchHandlers) == 0 {
			return
		}
		var e TabletPadGroupModeSwitchEvent
		l := 0
		e.Time = client.Uint32(data[l : l+4])
		l += 4
		e.Serial = client.Uint32(data[l : l+4])
		l += 4
		e.Mode = client.Uint32(data[l : l+4])
		l += 4
		for _, h := range i.modeSwitchHandlers {
			h.HandleTabletPadGroupModeSwitch(e)
		}
	}
}

// TabletPad : a set of buttons, rings and strips
//
// A pad device is a set of buttons, rings and strips
// usually physically present on the tablet device itself. Some
// exceptions exist where the pad device is physically detached, e.g. the
// Wacom ExpressKey Remote.
//
// Pad devices have no axes that control the cursor and are generally
// auxiliary devices to the tool devices used on the tablet surface.
//
// A pad device has a number of static characteristics, e.g. the number
// of rings. These capabilities are sent in an event sequence after the
// wp_tablet_seat.pad_added event before any actual events from this pad.
// This initial event sequence is terminated by a wp_tablet_pad.done
// event.
//
// All pad features (buttons, rings and strips) are logically divided into
// groups and all pads have at least one group. The available groups are
// notified through the wp_tablet_pad.group event; the compositor will
// emit one event per group before emitting wp_tablet_pad.done.
//
// Groups may have multiple modes. Modes allow clients to map multiple
// actions to a single pad feature. Only one mode can be active per group,
// although different groups may have different active modes.
type TabletPad struct {
	client.BaseProxy
	groupHandlers   []TabletPadGroupHandler
	pathHandlers    []TabletPadPathHandler
	buttonsHandlers []TabletPadButtonsHandler
	doneHandlers    []TabletPadDoneHandler
	buttonHandlers  []TabletPadButtonHandler
	enterHandlers   []TabletPadEnterHandler
	leaveHandlers   []TabletPadLeaveHandler
	removedHandlers []TabletPadRemovedHandler
}

// NewTabletPad : a set of buttons, rings and strips
//
// A pad device is a set of buttons, rings and strips
// usually physically present on the tablet device itself. Some
// exceptions exist where the pad device is physically detached, e.g. the
// Wacom ExpressKey Remote.
//
// Pad devices have no axes that control the cursor and are generally
// auxiliary devices to the tool devices used on the tablet surface.
//
// A pad device has a number of static characteristics, e.g. the number
// of rings. These capabilities are sent in an event sequence after the
// wp_tablet_seat.pad_added event before any actual events from this pad.
// This initial event sequence is terminated by a wp_tablet_pad.done
// event.
//
// All pad features (buttons, rings and strips) are logically divided into
// groups and all pads have at least one group. The available groups are
// notified through the wp_tablet_pad.group event; the compositor will
// emit one event per group before emitting wp_tablet_pad.done.
//
// Groups may have multiple modes. Modes allow clients to map multiple
// actions to a single pad feature. Only one mode can be active per group,
// although different groups may have different active modes.
func NewTabletPad(ctx *client.Context) *TabletPad {
	zwpTabletPadV2 := &TabletPad{}
	ctx.Register(zwpTabletPadV2)
	return zwpTabletPadV2
}

// SetFeedback : set compositor feedback
//
// Requests the compositor to use the provided feedback string
// associated with this button. This request should be issued immediately
// after a wp_tablet_pad_group.mode_switch event from the corresponding
// group is received, or whenever a button is mapped to a different
// action. See wp_tablet_pad_group.mode_switch for more details.
//
// Clients are encouraged to provide context-aware descriptions for
// the actions associated with each button, and compositors may use
// this information to offer visual feedback on the button layout
// (e.g. on-screen displays).
//
// Button indices start at 0. Setting the feedback string on a button
// that is reserved by the compositor (i.e. not belonging to any
// wp_tablet_pad_group) does not generate an error but the compositor
// is free to ignore the request.
//
// The provided string 'description' is a UTF-8 encoded string to be
// associated with this ring, and is considered user-visible; general
// internationalization rules apply.
//
// The serial argument will be that of the last
// wp_tablet_pad_group.mode_switch event received for the group of this
// button. Requests providing other serials than the most recent one will
// be ignored.
//
//  button: button index
//  description: button description
//  serial: serial of the mode switch event
func (i *TabletPad) SetFeedback(button uint32, description string, serial uint32) error {
	const opcode = 0
	descriptionLen := client.PaddedLen(len(description) + 1)
	rLen := 8 + 4 + (4 + descriptionLen) + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(r[l:l+4], uint32(button))
	l += 4
	client.PutString(r[l:l+(4+descriptionLen)], description, descriptionLen)
	l += (4 + descriptionLen)
	client.PutUint32(r[l:l+4], uint32(serial))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// Destroy : destroy the pad object
//
// Destroy the wp_tablet_pad object. Objects created from this object
// are unaffected and should be destroyed separately.
//
func (i *TabletPad) Destroy() error {
	defer i.Context().Unregister(i)
	const opcode = 1
	const rLen = 8
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

type TabletPadButtonState uint32

// TabletPadButtonState : physical button state
//
// Describes the physical state of a button that caused the button
// event.
const (
	// TabletPadButtonStateReleased : the button is not pressed
	TabletPadButtonStateReleased TabletPadButtonState = 0
	// TabletPadButtonStatePressed : the button is pressed
	TabletPadButtonStatePressed TabletPadButtonState = 1
)

func (e TabletPadButtonState) Name() string {
	switch e {
	case TabletPadButtonStateReleased:
		return "released"
	case TabletPadButtonStatePressed:
		return "pressed"
	default:
		return ""
	}
}

func (e TabletPadButtonState) Value() string {
	switch e {
	case TabletPadButtonStateReleased:
		return "0"
	case TabletPadButtonStatePressed:
		return "1"
	default:
		return ""
	}
}

func (e TabletPadButtonState) String() string {
	return e.Name() + "=" + e.Value()
}

// TabletPadGroupEvent : group announced
//
// Sent on wp_tablet_pad initialization to announce available groups.
// One event is sent for each pad group available.
//
// This event is sent in the initial burst of events before the
// wp_tablet_pad.done event. At least one group will be announced.
type TabletPadGroupEvent struct {
	PadGroup *TabletPadGroup
}

type TabletPadGroupHandler interface {
	HandleTabletPadGroup(TabletPadGroupEvent)
}

// AddGroupHandler : adds handler for TabletPadGroupEvent
func (i *TabletPad) AddGroupHandler(h TabletPadGroupHandler) {
	if h == nil {
		return
	}

	i.groupHandlers = append(i.groupHandlers, h)
}

func (i *TabletPad) RemoveGroupHandler(h TabletPadGroupHandler) {
	for j, e := range i.groupHandlers {
		if e == h {
			i.groupHandlers = append(i.groupHandlers[:j], i.groupHandlers[j+1:]...)
			break
		}
	}
}

// TabletPadPathEvent : path to the device
//
// A system-specific device path that indicates which device is behind
// this wp_tablet_pad. This information may be used to gather additional
// information about the device, e.g. through libwacom.
//
// The format of the path is unspecified, it may be a device node, a
// sysfs path, or some other identifier. It is up to the client to
// identify the string provided.
//
// This event is sent in the initial burst of events before the
// wp_tablet_pad.done event.
type TabletPadPathEvent struct {
	Path string
}

type TabletPadPathHandler interface {
	HandleTabletPadPath(TabletPadPathEvent)
}

// AddPathHandler : adds handler for TabletPadPathEvent
func (i *TabletPad) AddPathHandler(h TabletPadPathHandler) {
	if h == nil {
		return
	}

	i.pathHandlers = append(i.pathHandlers, h)
}

func (i *TabletPad) RemovePathHandler(h TabletPadPathHandler) {
	for j, e := range i.pathHandlers {
		if e == h {
			i.pathHandlers = append(i.pathHandlers[:j], i.pathHandlers[j+1:]...)
			break
		}
	}
}

// TabletPadButtonsEvent : buttons announced
//
// Sent on wp_tablet_pad initialization to announce the available
// buttons.
//
// This event is sent in the initial burst of events before the
// wp_tablet_pad.done event. This event is only sent when at least one
// button is available.
type TabletPadButtonsEvent struct {
	Buttons uint32
}

type TabletPadButtonsHandler interface {
	HandleTabletPadButtons(TabletPadButtonsEvent)
}

// AddButtonsHandler : adds handler for TabletPadButtonsEvent
func (i *TabletPad) AddButtonsHandler(h TabletPadButtonsHandler) {
	if h == nil {
		return
	}

	i.buttonsHandlers = append(i.buttonsHandlers, h)
}

func (i *TabletPad) RemoveButtonsHandler(h TabletPadButtonsHandler) {
	for j, e := range i.buttonsHandlers {
		if e == h {
			i.buttonsHandlers = append(i.buttonsHandlers[:j], i.buttonsHandlers[j+1:]...)
			break
		}
	}
}

// TabletPadDoneEvent : pad description event sequence complete
//
// This event signals the end of the initial burst of descriptive
// events. A client may consider the static description of the pad to
// be complete and finalize initialization of the pad.
type TabletPadDoneEvent struct{}
type TabletPadDoneHandler interface {
	HandleTabletPadDone(TabletPadDoneEvent)
}

// AddDoneHandler : adds handler for TabletPadDoneEvent
func (i *TabletPad) AddDoneHandler(h TabletPadDoneHandler) {
	if h == nil {
		return
	}

	i.doneHandlers = append(i.doneHandlers, h)
}

func (i *TabletPad) RemoveDoneHandler(h TabletPadDoneHandler) {
	for j, e := range i.doneHandlers {
		if e == h {
			i.doneHandlers = append(i.doneHandlers[:j], i.doneHandlers[j+1:]...)
			break
		}
	}
}

// TabletPadButtonEvent : physical button state
//
// Sent whenever the physical state of a button changes.
type TabletPadButtonEvent struct {
	Time   uint32
	Button uint32
	State  uint32
}

type TabletPadButtonHandler interface {
	HandleTabletPadButton(TabletPadButtonEvent)
}

// AddButtonHandler : adds handler for TabletPadButtonEvent
func (i *TabletPad) AddButtonHandler(h TabletPadButtonHandler) {
	if h == nil {
		return
	}

	i.buttonHandlers = append(i.buttonHandlers, h)
}

func (i *TabletPad) RemoveButtonHandler(h TabletPadButtonHandler) {
	for j, e := range i.buttonHandlers {
		if e == h {
			i.buttonHandlers = append(i.buttonHandlers[:j], i.buttonHandlers[j+1:]...)
			break
		}
	}
}

// TabletPadEnterEvent : enter event
//
// Notification that this pad is focused on the specified surface.
type TabletPadEnterEvent struct {
	Serial  uint32
	Tablet  *Tablet
	Surface *client.Surface
}

type TabletPadEnterHandler interface {
	HandleTabletPadEnter(TabletPadEnterEvent)
}

// AddEnterHandler : adds handler for TabletPadEnterEvent
func (i *TabletPad) AddEnterHandler(h TabletPadEnterHandler) {
	if h == nil {
		return
	}

	i.enterHandlers = append(i.enterHandlers, h)
}

func (i *TabletPad) RemoveEnterHandler(h TabletPadEnterHandler) {
	for j, e := range i.enterHandlers {
		if e == h {
			i.enterHandlers = append(i.enterHandlers[:j], i.enterHandlers[j+1:]...)
			break
		}
	}
}

// TabletPadLeaveEvent : enter event
//
// Notification that this pad is no longer focused on the specified
// surface.
type TabletPadLeaveEvent struct {
	Serial  uint32
	Surface *client.Surface
}

type TabletPadLeaveHandler interface {
	HandleTabletPadLeave(TabletPadLeaveEvent)
}

// AddLeaveHandler : adds handler for TabletPadLeaveEvent
func (i *TabletPad) AddLeaveHandler(h TabletPadLeaveHandler) {
	if h == nil {
		return
	}

	i.leaveHandlers = append(i.leaveHandlers, h)
}

func (i *TabletPad) RemoveLeaveHandler(h TabletPadLeaveHandler) {
	for j, e := range i.leaveHandlers {
		if e == h {
			i.leaveHandlers = append(i.leaveHandlers[:j], i.leaveHandlers[j+1:]...)
			break
		}
	}
}

// TabletPadRemovedEvent : pad removed event
//
// Sent when the pad has been removed from the system. When a tablet
// is removed its pad(s) will be removed too.
//
// When this event is received, the client must destroy all rings, strips
// and groups that were offered by this pad, and issue wp_tablet_pad.destroy
// the pad itself.
type TabletPadRemovedEvent struct{}
type TabletPadRemovedHandler interface {
	HandleTabletPadRemoved(TabletPadRemovedEvent)
}

// AddRemovedHandler : adds handler for TabletPadRemovedEvent
func (i *TabletPad) AddRemovedHandler(h TabletPadRemovedHandler) {
	if h == nil {
		return
	}

	i.removedHandlers = append(i.removedHandlers, h)
}

func (i *TabletPad) RemoveRemovedHandler(h TabletPadRemovedHandler) {
	for j, e := range i.removedHandlers {
		if e == h {
			i.removedHandlers = append(i.removedHandlers[:j], i.removedHandlers[j+1:]...)
			break
		}
	}
}

func (i *TabletPad) Dispatch(opcode uint16, fd uintptr, data []byte) {
	switch opcode {
	case 0:
		if len(i.groupHandlers) == 0 {
			return
		}
		var e TabletPadGroupEvent
		l := 0
		e.PadGroup = i.Context().GetProxy(client.Uint32(data[l : l+4])).(*TabletPadGroup)
		l += 4
		for _, h := range i.groupHandlers {
			h.HandleTabletPadGroup(e)
		}
	case 1:
		if len(i.pathHandlers) == 0 {
			return
		}
		var e TabletPadPathEvent
		l := 0
		pathLen := client.PaddedLen(int(client.Uint32(data[l : l+4])))
		l += 4
		e.Path = client.String(data[l : l+pathLen])
		l += pathLen
		for _, h := range i.pathHandlers {
			h.HandleTabletPadPath(e)
		}
	case 2:
		if len(i.buttonsHandlers) == 0 {
			return
		}
		var e TabletPadButtonsEvent
		l := 0
		e.Buttons = client.Uint32(data[l : l+4])
		l += 4
		for _, h := range i.buttonsHandlers {
			h.HandleTabletPadButtons(e)
		}
	case 3:
		if len(i.doneHandlers) == 0 {
			return
		}
		var e TabletPadDoneEvent
		for _, h := range i.doneHandlers {
			h.HandleTabletPadDone(e)
		}
	case 4:
		if len(i.buttonHandlers) == 0 {
			return
		}
		var e TabletPadButtonEvent
		l := 0
		e.Time = client.Uint32(data[l : l+4])
		l += 4
		e.Button = client.Uint32(data[l : l+4])
		l += 4
		e.State = client.Uint32(data[l : l+4])
		l += 4
		for _, h := range i.buttonHandlers {
			h.HandleTabletPadButton(e)
		}
	case 5:
		if len(i.enterHandlers) == 0 {
			return
		}
		var e TabletPadEnterEvent
		l := 0
		e.Serial = client.Uint32(data[l : l+4])
		l += 4
		e.Tablet = i.Context().GetProxy(client.Uint32(data[l : l+4])).(*Tablet)
		l += 4
		e.Surface = i.Context().GetProxy(client.Uint32(data[l : l+4])).(*client.Surface)
		l += 4
		for _, h := range i.enterHandlers {
			h.HandleTabletPadEnter(e)
		}
	case 6:
		if len(i.leaveHandlers) == 0 {
			return
		}
		var e TabletPadLeaveEvent
		l := 0
		e.Serial = client.Uint32(data[l : l+4])
		l += 4
		e.Surface = i.Context().GetProxy(client.Uint32(data[l : l+4])).(*client.Surface)
		l += 4
		for _, h := range i.leaveHandlers {
			h.HandleTabletPadLeave(e)
		}
	case 7:
		if len(i.removedHandlers) == 0 {
			return
		}
		var e TabletPadRemovedEvent
		for _, h := range i.removedHandlers {
			h.HandleTabletPadRemoved(e)
		}
	}
}
