// Generated by go-wayland-scanner
// https://github.com/rajveermalviya/go-wayland/cmd/go-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/d10d18f3d49374d2e3eb96d63511f32795aab5f7/unstable/text-input/text-input-unstable-v1.xml
//
// TextInputUnstableV1 Protocol Copyright:
//
// Copyright Â© 2012, 2013 Intel Corporation
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice (including the next
// paragraph) shall be included in all copies or substantial portions of the
// Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

package text_input

import (
	"sync"

	"github.com/rajveermalviya/go-wayland/client"
)

// ZwpTextInputV1 : text input
//
// An object used for text input. Adds support for text input and input
// methods to applications. A text_input object is created from a
// wl_text_input_manager and corresponds typically to a text entry in an
// application.
//
// Requests are used to activate/deactivate the text_input object and set
// state information like surrounding and selected text or the content type.
// The information about entered text is sent to the text_input object via
// the pre-edit and commit events. Using this interface removes the need
// for applications to directly process hardware key events and compose text
// out of them.
//
// Text is generally UTF-8 encoded, indices and lengths are in bytes.
//
// Serials are used to synchronize the state between the text input and
// an input method. New serials are sent by the text input in the
// commit_state request and are used by the input method to indicate
// the known text input state in events like preedit_string, commit_string,
// and keysym. The text input can then ignore events from the input method
// which are based on an outdated state (for example after a reset).
//
// Warning! The protocol described in this file is experimental and
// backward incompatible changes may be made. Backward compatible changes
// may be added together with the corresponding interface version bump.
// Backward incompatible changes are done by bumping the version number in
// the protocol and interface names and resetting the interface version.
// Once the protocol is to be declared stable, the 'z' prefix and the
// version number in the protocol and interface names are removed and the
// interface version number is reset.
type ZwpTextInputV1 struct {
	client.BaseProxy
	mu                            sync.RWMutex
	enterHandlers                 []ZwpTextInputV1EnterHandler
	leaveHandlers                 []ZwpTextInputV1LeaveHandler
	modifiersMapHandlers          []ZwpTextInputV1ModifiersMapHandler
	inputPanelStateHandlers       []ZwpTextInputV1InputPanelStateHandler
	preeditStringHandlers         []ZwpTextInputV1PreeditStringHandler
	preeditStylingHandlers        []ZwpTextInputV1PreeditStylingHandler
	preeditCursorHandlers         []ZwpTextInputV1PreeditCursorHandler
	commitStringHandlers          []ZwpTextInputV1CommitStringHandler
	cursorPositionHandlers        []ZwpTextInputV1CursorPositionHandler
	deleteSurroundingTextHandlers []ZwpTextInputV1DeleteSurroundingTextHandler
	keysymHandlers                []ZwpTextInputV1KeysymHandler
	languageHandlers              []ZwpTextInputV1LanguageHandler
	textDirectionHandlers         []ZwpTextInputV1TextDirectionHandler
}

// NewZwpTextInputV1 : text input
//
// An object used for text input. Adds support for text input and input
// methods to applications. A text_input object is created from a
// wl_text_input_manager and corresponds typically to a text entry in an
// application.
//
// Requests are used to activate/deactivate the text_input object and set
// state information like surrounding and selected text or the content type.
// The information about entered text is sent to the text_input object via
// the pre-edit and commit events. Using this interface removes the need
// for applications to directly process hardware key events and compose text
// out of them.
//
// Text is generally UTF-8 encoded, indices and lengths are in bytes.
//
// Serials are used to synchronize the state between the text input and
// an input method. New serials are sent by the text input in the
// commit_state request and are used by the input method to indicate
// the known text input state in events like preedit_string, commit_string,
// and keysym. The text input can then ignore events from the input method
// which are based on an outdated state (for example after a reset).
//
// Warning! The protocol described in this file is experimental and
// backward incompatible changes may be made. Backward compatible changes
// may be added together with the corresponding interface version bump.
// Backward incompatible changes are done by bumping the version number in
// the protocol and interface names and resetting the interface version.
// Once the protocol is to be declared stable, the 'z' prefix and the
// version number in the protocol and interface names are removed and the
// interface version number is reset.
func NewZwpTextInputV1(ctx *client.Context) *ZwpTextInputV1 {
	zwpTextInputV1 := &ZwpTextInputV1{}
	ctx.Register(zwpTextInputV1)
	return zwpTextInputV1
}

// Activate : request activation
//
// Requests the text_input object to be activated (typically when the
// text entry gets focus).
//
// The seat argument is a wl_seat which maintains the focus for this
// activation. The surface argument is a wl_surface assigned to the
// text_input object and tracked for focus lost. The enter event
// is emitted on successful activation.
//
func (i *ZwpTextInputV1) Activate(seat *client.WlSeat, surface *client.WlSurface) error {
	err := i.Context().SendRequest(i, 0, seat, surface)
	return err
}

// Deactivate : request deactivation
//
// Requests the text_input object to be deactivated (typically when the
// text entry lost focus). The seat argument is a wl_seat which was used
// for activation.
//
func (i *ZwpTextInputV1) Deactivate(seat *client.WlSeat) error {
	err := i.Context().SendRequest(i, 1, seat)
	return err
}

// ShowInputPanel : show input panels
//
// Requests input panels (virtual keyboard) to show.
//
func (i *ZwpTextInputV1) ShowInputPanel() error {
	err := i.Context().SendRequest(i, 2)
	return err
}

// HideInputPanel : hide input panels
//
// Requests input panels (virtual keyboard) to hide.
//
func (i *ZwpTextInputV1) HideInputPanel() error {
	err := i.Context().SendRequest(i, 3)
	return err
}

// Reset : reset
//
// Should be called by an editor widget when the input state should be
// reset, for example after the text was changed outside of the normal
// input method flow.
//
func (i *ZwpTextInputV1) Reset() error {
	err := i.Context().SendRequest(i, 4)
	return err
}

// SetSurroundingText : sets the surrounding text
//
// Sets the plain surrounding text around the input position. Text is
// UTF-8 encoded. Cursor is the byte offset within the
// surrounding text. Anchor is the byte offset of the
// selection anchor within the surrounding text. If there is no selected
// text anchor, then it is the same as cursor.
//
func (i *ZwpTextInputV1) SetSurroundingText(text string, cursor, anchor uint32) error {
	err := i.Context().SendRequest(i, 5, text, cursor, anchor)
	return err
}

// SetContentType : set content purpose and hint
//
// Sets the content purpose and content hint. While the purpose is the
// basic purpose of an input field, the hint flags allow to modify some
// of the behavior.
//
// When no content type is explicitly set, a normal content purpose with
// default hints (auto completion, auto correction, auto capitalization)
// should be assumed.
//
func (i *ZwpTextInputV1) SetContentType(hint, purpose uint32) error {
	err := i.Context().SendRequest(i, 6, hint, purpose)
	return err
}

// SetCursorRectangle :
//
func (i *ZwpTextInputV1) SetCursorRectangle(x, y, width, height int32) error {
	err := i.Context().SendRequest(i, 7, x, y, width, height)
	return err
}

// SetPreferredLanguage : sets preferred language
//
// Sets a specific language. This allows for example a virtual keyboard to
// show a language specific layout. The "language" argument is an RFC-3066
// format language tag.
//
// It could be used for example in a word processor to indicate the
// language of the currently edited document or in an instant message
// application which tracks languages of contacts.
//
func (i *ZwpTextInputV1) SetPreferredLanguage(language string) error {
	err := i.Context().SendRequest(i, 8, language)
	return err
}

// CommitState :
//
//  serial: used to identify the known state
func (i *ZwpTextInputV1) CommitState(serial uint32) error {
	err := i.Context().SendRequest(i, 9, serial)
	return err
}

// InvokeAction :
//
func (i *ZwpTextInputV1) InvokeAction(button, index uint32) error {
	err := i.Context().SendRequest(i, 10, button, index)
	return err
}

// ZwpTextInputV1ContentHint : content hint
//
// Content hint is a bitmask to allow to modify the behavior of the text
// input.
const (
	// ZwpTextInputV1ContentHintNone : no special behaviour
	ZwpTextInputV1ContentHintNone = 0x0
	// ZwpTextInputV1ContentHintDefault : auto completion, correction and capitalization
	ZwpTextInputV1ContentHintDefault = 0x7
	// ZwpTextInputV1ContentHintPassword : hidden and sensitive text
	ZwpTextInputV1ContentHintPassword = 0xc0
	// ZwpTextInputV1ContentHintAutoCompletion : suggest word completions
	ZwpTextInputV1ContentHintAutoCompletion = 0x1
	// ZwpTextInputV1ContentHintAutoCorrection : suggest word corrections
	ZwpTextInputV1ContentHintAutoCorrection = 0x2
	// ZwpTextInputV1ContentHintAutoCapitalization : switch to uppercase letters at the start of a sentence
	ZwpTextInputV1ContentHintAutoCapitalization = 0x4
	// ZwpTextInputV1ContentHintLowercase : prefer lowercase letters
	ZwpTextInputV1ContentHintLowercase = 0x8
	// ZwpTextInputV1ContentHintUppercase : prefer uppercase letters
	ZwpTextInputV1ContentHintUppercase = 0x10
	// ZwpTextInputV1ContentHintTitlecase : prefer casing for titles and headings (can be language dependent)
	ZwpTextInputV1ContentHintTitlecase = 0x20
	// ZwpTextInputV1ContentHintHiddenText : characters should be hidden
	ZwpTextInputV1ContentHintHiddenText = 0x40
	// ZwpTextInputV1ContentHintSensitiveData : typed text should not be stored
	ZwpTextInputV1ContentHintSensitiveData = 0x80
	// ZwpTextInputV1ContentHintLatin : just latin characters should be entered
	ZwpTextInputV1ContentHintLatin = 0x100
	// ZwpTextInputV1ContentHintMultiline : the text input is multiline
	ZwpTextInputV1ContentHintMultiline = 0x200
)

// ZwpTextInputV1ContentPurpose : content purpose
//
// The content purpose allows to specify the primary purpose of a text
// input.
//
// This allows an input method to show special purpose input panels with
// extra characters or to disallow some characters.
const (
	// ZwpTextInputV1ContentPurposeNormal : default input, allowing all characters
	ZwpTextInputV1ContentPurposeNormal = 0
	// ZwpTextInputV1ContentPurposeAlpha : allow only alphabetic characters
	ZwpTextInputV1ContentPurposeAlpha = 1
	// ZwpTextInputV1ContentPurposeDigits : allow only digits
	ZwpTextInputV1ContentPurposeDigits = 2
	// ZwpTextInputV1ContentPurposeNumber : input a number (including decimal separator and sign)
	ZwpTextInputV1ContentPurposeNumber = 3
	// ZwpTextInputV1ContentPurposePhone : input a phone number
	ZwpTextInputV1ContentPurposePhone = 4
	// ZwpTextInputV1ContentPurposeUrl : input an URL
	ZwpTextInputV1ContentPurposeUrl = 5
	// ZwpTextInputV1ContentPurposeEmail : input an email address
	ZwpTextInputV1ContentPurposeEmail = 6
	// ZwpTextInputV1ContentPurposeName : input a name of a person
	ZwpTextInputV1ContentPurposeName = 7
	// ZwpTextInputV1ContentPurposePassword : input a password (combine with password or sensitive_data hint)
	ZwpTextInputV1ContentPurposePassword = 8
	// ZwpTextInputV1ContentPurposeDate : input a date
	ZwpTextInputV1ContentPurposeDate = 9
	// ZwpTextInputV1ContentPurposeTime : input a time
	ZwpTextInputV1ContentPurposeTime = 10
	// ZwpTextInputV1ContentPurposeDatetime : input a date and time
	ZwpTextInputV1ContentPurposeDatetime = 11
	// ZwpTextInputV1ContentPurposeTerminal : input for a terminal
	ZwpTextInputV1ContentPurposeTerminal = 12
)

// ZwpTextInputV1PreeditStyle :
const (
	// ZwpTextInputV1PreeditStyleDefault : default style for composing text
	ZwpTextInputV1PreeditStyleDefault = 0
	// ZwpTextInputV1PreeditStyleNone : style should be the same as in non-composing text
	ZwpTextInputV1PreeditStyleNone      = 1
	ZwpTextInputV1PreeditStyleActive    = 2
	ZwpTextInputV1PreeditStyleInactive  = 3
	ZwpTextInputV1PreeditStyleHighlight = 4
	ZwpTextInputV1PreeditStyleUnderline = 5
	ZwpTextInputV1PreeditStyleSelection = 6
	ZwpTextInputV1PreeditStyleIncorrect = 7
)

// ZwpTextInputV1TextDirection :
const (
	// ZwpTextInputV1TextDirectionAuto : automatic text direction based on text and language
	ZwpTextInputV1TextDirectionAuto = 0
	// ZwpTextInputV1TextDirectionLtr : left-to-right
	ZwpTextInputV1TextDirectionLtr = 1
	// ZwpTextInputV1TextDirectionRtl : right-to-left
	ZwpTextInputV1TextDirectionRtl = 2
)

// ZwpTextInputV1EnterEvent : enter event
//
// Notify the text_input object when it received focus. Typically in
// response to an activate request.
type ZwpTextInputV1EnterEvent struct {
	Surface *client.WlSurface
}

type ZwpTextInputV1EnterHandler interface {
	HandleZwpTextInputV1Enter(ZwpTextInputV1EnterEvent)
}

// AddEnterHandler : adds handler for ZwpTextInputV1EnterEvent
func (i *ZwpTextInputV1) AddEnterHandler(h ZwpTextInputV1EnterHandler) {
	if h == nil {
		return
	}

	i.mu.Lock()
	i.enterHandlers = append(i.enterHandlers, h)
	i.mu.Unlock()
}

func (i *ZwpTextInputV1) RemoveEnterHandler(h ZwpTextInputV1EnterHandler) {
	i.mu.Lock()
	defer i.mu.Unlock()

	for j, e := range i.enterHandlers {
		if e == h {
			i.enterHandlers = append(i.enterHandlers[:j], i.enterHandlers[j+1:]...)
			break
		}
	}
}

// ZwpTextInputV1LeaveEvent : leave event
//
// Notify the text_input object when it lost focus. Either in response
// to a deactivate request or when the assigned surface lost focus or was
// destroyed.
type ZwpTextInputV1LeaveEvent struct{}
type ZwpTextInputV1LeaveHandler interface {
	HandleZwpTextInputV1Leave(ZwpTextInputV1LeaveEvent)
}

// AddLeaveHandler : adds handler for ZwpTextInputV1LeaveEvent
func (i *ZwpTextInputV1) AddLeaveHandler(h ZwpTextInputV1LeaveHandler) {
	if h == nil {
		return
	}

	i.mu.Lock()
	i.leaveHandlers = append(i.leaveHandlers, h)
	i.mu.Unlock()
}

func (i *ZwpTextInputV1) RemoveLeaveHandler(h ZwpTextInputV1LeaveHandler) {
	i.mu.Lock()
	defer i.mu.Unlock()

	for j, e := range i.leaveHandlers {
		if e == h {
			i.leaveHandlers = append(i.leaveHandlers[:j], i.leaveHandlers[j+1:]...)
			break
		}
	}
}

// ZwpTextInputV1ModifiersMapEvent : modifiers map
//
// Transfer an array of 0-terminated modifier names. The position in
// the array is the index of the modifier as used in the modifiers
// bitmask in the keysym event.
type ZwpTextInputV1ModifiersMapEvent struct {
	Map []int32
}

type ZwpTextInputV1ModifiersMapHandler interface {
	HandleZwpTextInputV1ModifiersMap(ZwpTextInputV1ModifiersMapEvent)
}

// AddModifiersMapHandler : adds handler for ZwpTextInputV1ModifiersMapEvent
func (i *ZwpTextInputV1) AddModifiersMapHandler(h ZwpTextInputV1ModifiersMapHandler) {
	if h == nil {
		return
	}

	i.mu.Lock()
	i.modifiersMapHandlers = append(i.modifiersMapHandlers, h)
	i.mu.Unlock()
}

func (i *ZwpTextInputV1) RemoveModifiersMapHandler(h ZwpTextInputV1ModifiersMapHandler) {
	i.mu.Lock()
	defer i.mu.Unlock()

	for j, e := range i.modifiersMapHandlers {
		if e == h {
			i.modifiersMapHandlers = append(i.modifiersMapHandlers[:j], i.modifiersMapHandlers[j+1:]...)
			break
		}
	}
}

// ZwpTextInputV1InputPanelStateEvent : state of the input panel
//
// Notify when the visibility state of the input panel changed.
type ZwpTextInputV1InputPanelStateEvent struct {
	State uint32
}

type ZwpTextInputV1InputPanelStateHandler interface {
	HandleZwpTextInputV1InputPanelState(ZwpTextInputV1InputPanelStateEvent)
}

// AddInputPanelStateHandler : adds handler for ZwpTextInputV1InputPanelStateEvent
func (i *ZwpTextInputV1) AddInputPanelStateHandler(h ZwpTextInputV1InputPanelStateHandler) {
	if h == nil {
		return
	}

	i.mu.Lock()
	i.inputPanelStateHandlers = append(i.inputPanelStateHandlers, h)
	i.mu.Unlock()
}

func (i *ZwpTextInputV1) RemoveInputPanelStateHandler(h ZwpTextInputV1InputPanelStateHandler) {
	i.mu.Lock()
	defer i.mu.Unlock()

	for j, e := range i.inputPanelStateHandlers {
		if e == h {
			i.inputPanelStateHandlers = append(i.inputPanelStateHandlers[:j], i.inputPanelStateHandlers[j+1:]...)
			break
		}
	}
}

// ZwpTextInputV1PreeditStringEvent : pre-edit
//
// Notify when a new composing text (pre-edit) should be set around the
// current cursor position. Any previously set composing text should
// be removed.
//
// The commit text can be used to replace the preedit text on reset
// (for example on unfocus).
//
// The text input should also handle all preedit_style and preedit_cursor
// events occurring directly before preedit_string.
type ZwpTextInputV1PreeditStringEvent struct {
	Serial uint32
	Text   string
	Commit string
}

type ZwpTextInputV1PreeditStringHandler interface {
	HandleZwpTextInputV1PreeditString(ZwpTextInputV1PreeditStringEvent)
}

// AddPreeditStringHandler : adds handler for ZwpTextInputV1PreeditStringEvent
func (i *ZwpTextInputV1) AddPreeditStringHandler(h ZwpTextInputV1PreeditStringHandler) {
	if h == nil {
		return
	}

	i.mu.Lock()
	i.preeditStringHandlers = append(i.preeditStringHandlers, h)
	i.mu.Unlock()
}

func (i *ZwpTextInputV1) RemovePreeditStringHandler(h ZwpTextInputV1PreeditStringHandler) {
	i.mu.Lock()
	defer i.mu.Unlock()

	for j, e := range i.preeditStringHandlers {
		if e == h {
			i.preeditStringHandlers = append(i.preeditStringHandlers[:j], i.preeditStringHandlers[j+1:]...)
			break
		}
	}
}

// ZwpTextInputV1PreeditStylingEvent : pre-edit styling
//
// Sets styling information on composing text. The style is applied for
// length bytes from index relative to the beginning of the composing
// text (as byte offset). Multiple styles can
// be applied to a composing text by sending multiple preedit_styling
// events.
//
// This event is handled as part of a following preedit_string event.
type ZwpTextInputV1PreeditStylingEvent struct {
	Index  uint32
	Length uint32
	Style  uint32
}

type ZwpTextInputV1PreeditStylingHandler interface {
	HandleZwpTextInputV1PreeditStyling(ZwpTextInputV1PreeditStylingEvent)
}

// AddPreeditStylingHandler : adds handler for ZwpTextInputV1PreeditStylingEvent
func (i *ZwpTextInputV1) AddPreeditStylingHandler(h ZwpTextInputV1PreeditStylingHandler) {
	if h == nil {
		return
	}

	i.mu.Lock()
	i.preeditStylingHandlers = append(i.preeditStylingHandlers, h)
	i.mu.Unlock()
}

func (i *ZwpTextInputV1) RemovePreeditStylingHandler(h ZwpTextInputV1PreeditStylingHandler) {
	i.mu.Lock()
	defer i.mu.Unlock()

	for j, e := range i.preeditStylingHandlers {
		if e == h {
			i.preeditStylingHandlers = append(i.preeditStylingHandlers[:j], i.preeditStylingHandlers[j+1:]...)
			break
		}
	}
}

// ZwpTextInputV1PreeditCursorEvent : pre-edit cursor
//
// Sets the cursor position inside the composing text (as byte
// offset) relative to the start of the composing text. When index is a
// negative number no cursor is shown.
//
// This event is handled as part of a following preedit_string event.
type ZwpTextInputV1PreeditCursorEvent struct {
	Index int32
}

type ZwpTextInputV1PreeditCursorHandler interface {
	HandleZwpTextInputV1PreeditCursor(ZwpTextInputV1PreeditCursorEvent)
}

// AddPreeditCursorHandler : adds handler for ZwpTextInputV1PreeditCursorEvent
func (i *ZwpTextInputV1) AddPreeditCursorHandler(h ZwpTextInputV1PreeditCursorHandler) {
	if h == nil {
		return
	}

	i.mu.Lock()
	i.preeditCursorHandlers = append(i.preeditCursorHandlers, h)
	i.mu.Unlock()
}

func (i *ZwpTextInputV1) RemovePreeditCursorHandler(h ZwpTextInputV1PreeditCursorHandler) {
	i.mu.Lock()
	defer i.mu.Unlock()

	for j, e := range i.preeditCursorHandlers {
		if e == h {
			i.preeditCursorHandlers = append(i.preeditCursorHandlers[:j], i.preeditCursorHandlers[j+1:]...)
			break
		}
	}
}

// ZwpTextInputV1CommitStringEvent : commit
//
// Notify when text should be inserted into the editor widget. The text to
// commit could be either just a single character after a key press or the
// result of some composing (pre-edit). It could also be an empty text
// when some text should be removed (see delete_surrounding_text) or when
// the input cursor should be moved (see cursor_position).
//
// Any previously set composing text should be removed.
type ZwpTextInputV1CommitStringEvent struct {
	Serial uint32
	Text   string
}

type ZwpTextInputV1CommitStringHandler interface {
	HandleZwpTextInputV1CommitString(ZwpTextInputV1CommitStringEvent)
}

// AddCommitStringHandler : adds handler for ZwpTextInputV1CommitStringEvent
func (i *ZwpTextInputV1) AddCommitStringHandler(h ZwpTextInputV1CommitStringHandler) {
	if h == nil {
		return
	}

	i.mu.Lock()
	i.commitStringHandlers = append(i.commitStringHandlers, h)
	i.mu.Unlock()
}

func (i *ZwpTextInputV1) RemoveCommitStringHandler(h ZwpTextInputV1CommitStringHandler) {
	i.mu.Lock()
	defer i.mu.Unlock()

	for j, e := range i.commitStringHandlers {
		if e == h {
			i.commitStringHandlers = append(i.commitStringHandlers[:j], i.commitStringHandlers[j+1:]...)
			break
		}
	}
}

// ZwpTextInputV1CursorPositionEvent : set cursor to new position
//
// Notify when the cursor or anchor position should be modified.
//
// This event should be handled as part of a following commit_string
// event.
type ZwpTextInputV1CursorPositionEvent struct {
	Index  int32
	Anchor int32
}

type ZwpTextInputV1CursorPositionHandler interface {
	HandleZwpTextInputV1CursorPosition(ZwpTextInputV1CursorPositionEvent)
}

// AddCursorPositionHandler : adds handler for ZwpTextInputV1CursorPositionEvent
func (i *ZwpTextInputV1) AddCursorPositionHandler(h ZwpTextInputV1CursorPositionHandler) {
	if h == nil {
		return
	}

	i.mu.Lock()
	i.cursorPositionHandlers = append(i.cursorPositionHandlers, h)
	i.mu.Unlock()
}

func (i *ZwpTextInputV1) RemoveCursorPositionHandler(h ZwpTextInputV1CursorPositionHandler) {
	i.mu.Lock()
	defer i.mu.Unlock()

	for j, e := range i.cursorPositionHandlers {
		if e == h {
			i.cursorPositionHandlers = append(i.cursorPositionHandlers[:j], i.cursorPositionHandlers[j+1:]...)
			break
		}
	}
}

// ZwpTextInputV1DeleteSurroundingTextEvent : delete surrounding text
//
// Notify when the text around the current cursor position should be
// deleted.
//
// Index is relative to the current cursor (in bytes).
// Length is the length of deleted text (in bytes).
//
// This event should be handled as part of a following commit_string
// event.
type ZwpTextInputV1DeleteSurroundingTextEvent struct {
	Index  int32
	Length uint32
}

type ZwpTextInputV1DeleteSurroundingTextHandler interface {
	HandleZwpTextInputV1DeleteSurroundingText(ZwpTextInputV1DeleteSurroundingTextEvent)
}

// AddDeleteSurroundingTextHandler : adds handler for ZwpTextInputV1DeleteSurroundingTextEvent
func (i *ZwpTextInputV1) AddDeleteSurroundingTextHandler(h ZwpTextInputV1DeleteSurroundingTextHandler) {
	if h == nil {
		return
	}

	i.mu.Lock()
	i.deleteSurroundingTextHandlers = append(i.deleteSurroundingTextHandlers, h)
	i.mu.Unlock()
}

func (i *ZwpTextInputV1) RemoveDeleteSurroundingTextHandler(h ZwpTextInputV1DeleteSurroundingTextHandler) {
	i.mu.Lock()
	defer i.mu.Unlock()

	for j, e := range i.deleteSurroundingTextHandlers {
		if e == h {
			i.deleteSurroundingTextHandlers = append(i.deleteSurroundingTextHandlers[:j], i.deleteSurroundingTextHandlers[j+1:]...)
			break
		}
	}
}

// ZwpTextInputV1KeysymEvent : keysym
//
// Notify when a key event was sent. Key events should not be used
// for normal text input operations, which should be done with
// commit_string, delete_surrounding_text, etc. The key event follows
// the wl_keyboard key event convention. Sym is an XKB keysym, state a
// wl_keyboard key_state. Modifiers are a mask for effective modifiers
// (where the modifier indices are set by the modifiers_map event)
type ZwpTextInputV1KeysymEvent struct {
	Serial    uint32
	Time      uint32
	Sym       uint32
	State     uint32
	Modifiers uint32
}

type ZwpTextInputV1KeysymHandler interface {
	HandleZwpTextInputV1Keysym(ZwpTextInputV1KeysymEvent)
}

// AddKeysymHandler : adds handler for ZwpTextInputV1KeysymEvent
func (i *ZwpTextInputV1) AddKeysymHandler(h ZwpTextInputV1KeysymHandler) {
	if h == nil {
		return
	}

	i.mu.Lock()
	i.keysymHandlers = append(i.keysymHandlers, h)
	i.mu.Unlock()
}

func (i *ZwpTextInputV1) RemoveKeysymHandler(h ZwpTextInputV1KeysymHandler) {
	i.mu.Lock()
	defer i.mu.Unlock()

	for j, e := range i.keysymHandlers {
		if e == h {
			i.keysymHandlers = append(i.keysymHandlers[:j], i.keysymHandlers[j+1:]...)
			break
		}
	}
}

// ZwpTextInputV1LanguageEvent : language
//
// Sets the language of the input text. The "language" argument is an
// RFC-3066 format language tag.
type ZwpTextInputV1LanguageEvent struct {
	Serial   uint32
	Language string
}

type ZwpTextInputV1LanguageHandler interface {
	HandleZwpTextInputV1Language(ZwpTextInputV1LanguageEvent)
}

// AddLanguageHandler : adds handler for ZwpTextInputV1LanguageEvent
func (i *ZwpTextInputV1) AddLanguageHandler(h ZwpTextInputV1LanguageHandler) {
	if h == nil {
		return
	}

	i.mu.Lock()
	i.languageHandlers = append(i.languageHandlers, h)
	i.mu.Unlock()
}

func (i *ZwpTextInputV1) RemoveLanguageHandler(h ZwpTextInputV1LanguageHandler) {
	i.mu.Lock()
	defer i.mu.Unlock()

	for j, e := range i.languageHandlers {
		if e == h {
			i.languageHandlers = append(i.languageHandlers[:j], i.languageHandlers[j+1:]...)
			break
		}
	}
}

// ZwpTextInputV1TextDirectionEvent : text direction
//
// Sets the text direction of input text.
//
// It is mainly needed for showing an input cursor on the correct side of
// the editor when there is no input done yet and making sure neutral
// direction text is laid out properly.
type ZwpTextInputV1TextDirectionEvent struct {
	Serial    uint32
	Direction uint32
}

type ZwpTextInputV1TextDirectionHandler interface {
	HandleZwpTextInputV1TextDirection(ZwpTextInputV1TextDirectionEvent)
}

// AddTextDirectionHandler : adds handler for ZwpTextInputV1TextDirectionEvent
func (i *ZwpTextInputV1) AddTextDirectionHandler(h ZwpTextInputV1TextDirectionHandler) {
	if h == nil {
		return
	}

	i.mu.Lock()
	i.textDirectionHandlers = append(i.textDirectionHandlers, h)
	i.mu.Unlock()
}

func (i *ZwpTextInputV1) RemoveTextDirectionHandler(h ZwpTextInputV1TextDirectionHandler) {
	i.mu.Lock()
	defer i.mu.Unlock()

	for j, e := range i.textDirectionHandlers {
		if e == h {
			i.textDirectionHandlers = append(i.textDirectionHandlers[:j], i.textDirectionHandlers[j+1:]...)
			break
		}
	}
}

func (i *ZwpTextInputV1) Dispatch(event *client.Event) {
	switch event.Opcode {
	case 0:
		i.mu.RLock()
		if len(i.enterHandlers) == 0 {
			i.mu.RUnlock()
			break
		}
		i.mu.RUnlock()

		e := ZwpTextInputV1EnterEvent{
			Surface: event.Proxy(i.Context()).(*client.WlSurface),
		}

		i.mu.RLock()
		for _, h := range i.enterHandlers {
			i.mu.RUnlock()

			h.HandleZwpTextInputV1Enter(e)

			i.mu.RLock()
		}
		i.mu.RUnlock()
	case 1:
		i.mu.RLock()
		if len(i.leaveHandlers) == 0 {
			i.mu.RUnlock()
			break
		}
		i.mu.RUnlock()

		e := ZwpTextInputV1LeaveEvent{}

		i.mu.RLock()
		for _, h := range i.leaveHandlers {
			i.mu.RUnlock()

			h.HandleZwpTextInputV1Leave(e)

			i.mu.RLock()
		}
		i.mu.RUnlock()
	case 2:
		i.mu.RLock()
		if len(i.modifiersMapHandlers) == 0 {
			i.mu.RUnlock()
			break
		}
		i.mu.RUnlock()

		e := ZwpTextInputV1ModifiersMapEvent{
			Map: event.Array(),
		}

		i.mu.RLock()
		for _, h := range i.modifiersMapHandlers {
			i.mu.RUnlock()

			h.HandleZwpTextInputV1ModifiersMap(e)

			i.mu.RLock()
		}
		i.mu.RUnlock()
	case 3:
		i.mu.RLock()
		if len(i.inputPanelStateHandlers) == 0 {
			i.mu.RUnlock()
			break
		}
		i.mu.RUnlock()

		e := ZwpTextInputV1InputPanelStateEvent{
			State: event.Uint32(),
		}

		i.mu.RLock()
		for _, h := range i.inputPanelStateHandlers {
			i.mu.RUnlock()

			h.HandleZwpTextInputV1InputPanelState(e)

			i.mu.RLock()
		}
		i.mu.RUnlock()
	case 4:
		i.mu.RLock()
		if len(i.preeditStringHandlers) == 0 {
			i.mu.RUnlock()
			break
		}
		i.mu.RUnlock()

		e := ZwpTextInputV1PreeditStringEvent{
			Serial: event.Uint32(),
			Text:   event.String(),
			Commit: event.String(),
		}

		i.mu.RLock()
		for _, h := range i.preeditStringHandlers {
			i.mu.RUnlock()

			h.HandleZwpTextInputV1PreeditString(e)

			i.mu.RLock()
		}
		i.mu.RUnlock()
	case 5:
		i.mu.RLock()
		if len(i.preeditStylingHandlers) == 0 {
			i.mu.RUnlock()
			break
		}
		i.mu.RUnlock()

		e := ZwpTextInputV1PreeditStylingEvent{
			Index:  event.Uint32(),
			Length: event.Uint32(),
			Style:  event.Uint32(),
		}

		i.mu.RLock()
		for _, h := range i.preeditStylingHandlers {
			i.mu.RUnlock()

			h.HandleZwpTextInputV1PreeditStyling(e)

			i.mu.RLock()
		}
		i.mu.RUnlock()
	case 6:
		i.mu.RLock()
		if len(i.preeditCursorHandlers) == 0 {
			i.mu.RUnlock()
			break
		}
		i.mu.RUnlock()

		e := ZwpTextInputV1PreeditCursorEvent{
			Index: event.Int32(),
		}

		i.mu.RLock()
		for _, h := range i.preeditCursorHandlers {
			i.mu.RUnlock()

			h.HandleZwpTextInputV1PreeditCursor(e)

			i.mu.RLock()
		}
		i.mu.RUnlock()
	case 7:
		i.mu.RLock()
		if len(i.commitStringHandlers) == 0 {
			i.mu.RUnlock()
			break
		}
		i.mu.RUnlock()

		e := ZwpTextInputV1CommitStringEvent{
			Serial: event.Uint32(),
			Text:   event.String(),
		}

		i.mu.RLock()
		for _, h := range i.commitStringHandlers {
			i.mu.RUnlock()

			h.HandleZwpTextInputV1CommitString(e)

			i.mu.RLock()
		}
		i.mu.RUnlock()
	case 8:
		i.mu.RLock()
		if len(i.cursorPositionHandlers) == 0 {
			i.mu.RUnlock()
			break
		}
		i.mu.RUnlock()

		e := ZwpTextInputV1CursorPositionEvent{
			Index:  event.Int32(),
			Anchor: event.Int32(),
		}

		i.mu.RLock()
		for _, h := range i.cursorPositionHandlers {
			i.mu.RUnlock()

			h.HandleZwpTextInputV1CursorPosition(e)

			i.mu.RLock()
		}
		i.mu.RUnlock()
	case 9:
		i.mu.RLock()
		if len(i.deleteSurroundingTextHandlers) == 0 {
			i.mu.RUnlock()
			break
		}
		i.mu.RUnlock()

		e := ZwpTextInputV1DeleteSurroundingTextEvent{
			Index:  event.Int32(),
			Length: event.Uint32(),
		}

		i.mu.RLock()
		for _, h := range i.deleteSurroundingTextHandlers {
			i.mu.RUnlock()

			h.HandleZwpTextInputV1DeleteSurroundingText(e)

			i.mu.RLock()
		}
		i.mu.RUnlock()
	case 10:
		i.mu.RLock()
		if len(i.keysymHandlers) == 0 {
			i.mu.RUnlock()
			break
		}
		i.mu.RUnlock()

		e := ZwpTextInputV1KeysymEvent{
			Serial:    event.Uint32(),
			Time:      event.Uint32(),
			Sym:       event.Uint32(),
			State:     event.Uint32(),
			Modifiers: event.Uint32(),
		}

		i.mu.RLock()
		for _, h := range i.keysymHandlers {
			i.mu.RUnlock()

			h.HandleZwpTextInputV1Keysym(e)

			i.mu.RLock()
		}
		i.mu.RUnlock()
	case 11:
		i.mu.RLock()
		if len(i.languageHandlers) == 0 {
			i.mu.RUnlock()
			break
		}
		i.mu.RUnlock()

		e := ZwpTextInputV1LanguageEvent{
			Serial:   event.Uint32(),
			Language: event.String(),
		}

		i.mu.RLock()
		for _, h := range i.languageHandlers {
			i.mu.RUnlock()

			h.HandleZwpTextInputV1Language(e)

			i.mu.RLock()
		}
		i.mu.RUnlock()
	case 12:
		i.mu.RLock()
		if len(i.textDirectionHandlers) == 0 {
			i.mu.RUnlock()
			break
		}
		i.mu.RUnlock()

		e := ZwpTextInputV1TextDirectionEvent{
			Serial:    event.Uint32(),
			Direction: event.Uint32(),
		}

		i.mu.RLock()
		for _, h := range i.textDirectionHandlers {
			i.mu.RUnlock()

			h.HandleZwpTextInputV1TextDirection(e)

			i.mu.RLock()
		}
		i.mu.RUnlock()
	}
}

// ZwpTextInputManagerV1 : text input manager
//
// A factory for text_input objects. This object is a global singleton.
type ZwpTextInputManagerV1 struct {
	client.BaseProxy
}

// NewZwpTextInputManagerV1 : text input manager
//
// A factory for text_input objects. This object is a global singleton.
func NewZwpTextInputManagerV1(ctx *client.Context) *ZwpTextInputManagerV1 {
	zwpTextInputManagerV1 := &ZwpTextInputManagerV1{}
	ctx.Register(zwpTextInputManagerV1)
	return zwpTextInputManagerV1
}

// CreateTextInput : create text input
//
// Creates a new text_input object.
//
func (i *ZwpTextInputManagerV1) CreateTextInput() (*ZwpTextInputV1, error) {
	id := NewZwpTextInputV1(i.Context())
	err := i.Context().SendRequest(i, 0, id)
	return id, err
}
